
현재 Cross-Domain 의존성 문제
WorkflowModule:

@git/domain/ports/git-repository.js → GitRepository 직접 import
@mcp/domain/ports/mcp-server-repository.js → McpServerRepository 직접 import
GitModule, McpModule 직접 import
WorkflowRuntimeModule:

@workflow/domain/ports/workflow-repository.js → WorkflowRepository 직접 import
@mcp/domain/ports/mcp-server-repository.js → McpServerRepository 직접 import
WorkflowModule, McpModule 직접 import
해결 방법: Query Adapter 패턴으로 완전 분리
핵심 아이디어는 모듈 간에 Repository를 직접 주입받는 대신, @common/ports에 정의된 Query Adapter(Reader) 인터페이스만 사용하는 것입니다.

현재 (결합)

WorkflowModule --import--> GitModule (GitRepository를 직접 inject)
WorkflowModule --import--> McpModule (McpServerRepository를 직접 inject)
목표 (분리)

WorkflowModule → GitReferenceChecker (common port)만 의존
GitModule → GitReferenceChecker 구현체를 자기가 직접 provide & export

WorkflowModule은 GitModule의 존재를 모른다.
구체적인 변경
1단계 — 각 도메인 모듈이 자기 어댑터를 직접 제공 & export


// git.module.ts
@Module({
  providers: [
    { provide: GitRepository, useClass: InMemoryGitRepository },
    {
      provide: GitReferenceChecker,  // common port
      useFactory: (repo: GitRepository) =>
        new GitReferenceCheckerImpl((ids) => repo.findByIds(ids)),
      inject: [GitRepository],
    },
  ],
  exports: [GitReferenceChecker],  // Repository가 아닌 Adapter를 export
})

// mcp.module.ts — McpServerReferenceChecker, McpServerReader 둘 다 여기서 제공
@Module({
  providers: [
    { provide: McpServerRepository, useClass: InMemoryMcpServerRepository },
    {
      provide: McpServerReferenceChecker,
      useFactory: (repo) => new McpServerReferenceCheckerImpl(...),
      inject: [McpServerRepository],
    },
    {
      provide: McpServerReader,
      useFactory: (repo) => new McpServerReaderImpl(...),
      inject: [McpServerRepository],
    },
  ],
  exports: [McpServerReferenceChecker, McpServerReader],
})

// workflow.module.ts — WorkflowConfigReader를 여기서 제공
@Module({
  providers: [
    { provide: WorkflowRepository, useClass: InMemoryWorkflowRepository },
    {
      provide: WorkflowConfigReader,
      useFactory: (repo) => new WorkflowConfigReaderImpl(...),
      inject: [WorkflowRepository],
    },
  ],
  exports: [WorkflowConfigReader],  // Repository가 아닌 Reader를 export
})
2단계 — 소비하는 모듈은 common port만 import


// workflow.module.ts
import { GitReferenceChecker, McpServerReferenceChecker } from '@common/ports/index.js';
// @git/*, @mcp/* import 전혀 없음!

@Module({
  imports: [SharedModule, GitModule, McpModule],  // 여전히 import하지만...
  providers: [
    // GitReferenceChecker, McpServerReferenceChecker는 
    // GitModule, McpModule이 export해주므로 바로 사용 가능
    CreateWorkflowUseCase,
    ...
  ],
})
3단계 (선택) — 모듈 import도 제거하고 AppModule에서 조립

NestJS의 Global() 데코레이터를 활용하거나, AppModule에서 모든 cross-domain adapter를 조립하면 모듈 간 import도 완전히 제거할 수 있습니다:


// app.module.ts (Composition Root)
@Module({
  imports: [SharedModule, GitModule, McpModule, WorkflowModule, WorkflowRuntimeModule, AgentModule],
})
export class AppModule {}
각 모듈이 @Global()로 자기 어댑터를 export하면, 다른 모듈에서 import 없이 주입받을 수 있습니다.

원칙 정리
Before	After
WorkflowModule이 GitRepository 직접 inject	GitModule이 GitReferenceChecker 제공 & export
모듈이 다른 도메인의 Repository를 export	모듈이 @common/ports Adapter만 export
@git/domain/ports import	@common/ports import만
"자기 데이터는 자기가 읽어서 어댑터로 포장해 내보낸다" — 이것이 핵심입니다. 소비하는 쪽은 데이터의 출처(어느 도메인)를 알 필요가 없고, @common/ports에 정의된 인터페이스만 의존합니다.