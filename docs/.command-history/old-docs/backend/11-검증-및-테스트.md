# 검증 및 테스트

## 1. 입력 검증(Validation) 계층

입력 검증은 세 계층에 걸쳐 수행된다. 각 계층은 자신의 관심사에 맞는 검증만 수행하며, 상위 계층에서 하위 계층으로 갈수록 비즈니스 규칙에 가까워진다.

```
Presentation Layer   → 형식(format) 검증: 요청 DTO의 타입, 필수 필드, 길이 제한
Application Layer    → 비즈니스 규칙 검증: 엔티티 존재 여부, 상태 전이 가능 여부
Domain Layer         → 불변식(invariant) 검증: Aggregate 규칙, Value Object 생성 시 제약
```

### 1.1 Presentation Layer — Request DTO 형식 검증

HTTP 요청이 Controller에 도달하는 시점에서 수행한다. `zod` 또는 `class-validator` 등을 사용하여 DTO의 구조적 유효성을 검증한다.

| 검증 대상 | 검증 내용 | 실패 시 |
|-----------|----------|---------|
| 필수 필드 누락 | `url`, `templateId` 등 required 필드 존재 여부 | `400 Bad Request` |
| 타입 불일치 | `string` 대신 `number`가 전달된 경우 | `400 Bad Request` |
| 길이 제한 | `query`가 50000자 초과, `name`이 빈 문자열 | `400 Bad Request` |
| 배열 구조 | `workDefinitions`가 비어있는 경우, `gitRefs` 중복 | `400 Bad Request` |
| Enum 값 | `transportType`이 허용된 값이 아닌 경우 | `400 Bad Request` |

**원칙**: Presentation Layer 검증은 도메인 지식 없이 순수한 형식 검증만 수행한다. "해당 Git이 존재하는가?"는 이 계층의 관심사가 아니다.

### 1.2 Application Layer — 비즈니스 규칙 검증

UseCase 실행 시 도메인 객체를 조회하고 비즈니스 규칙을 검증한다.

| 검증 대상 | 검증 내용 | 실패 시 |
|-----------|----------|---------|
| 엔티티 존재 | `GitRepository.findById(gitId)` 결과가 null | `404 Not Found` |
| 참조 무결성 | `gitRefs`의 모든 `gitId`가 GitRepository에 존재 | `404 Not Found` |
| 상태 전이 가능 여부 | `workflow.canStart()`, `workflow.canResume()` | `409 Conflict` |
| 삭제 가능 여부 | `git.canDelete()` — activeWorkflowIds 비어있는지 | `409 Conflict` |
| 중복 검증 | 동일 `url`의 Git이 이미 등록되어 있는지 | `409 Conflict` |

### 1.3 Domain Layer — Aggregate 불변식, Value Object 생성 시 검증

도메인 객체 생성 또는 상태 변경 시 자기 자신의 불변식을 보호한다. 위반 시 도메인 예외를 발생시킨다.

| 검증 주체 | 검증 내용 | 예외 |
|-----------|----------|------|
| Value Object 생성자 | `GitUrl` 형식, `CommitHash` 정규식 매칭 | `InvalidValueObjectError` |
| Aggregate Command | `workflow.start()` 시 상태가 `READY`인지 | `InvalidStateTransitionError` |
| Aggregate 불변식 | `work.advanceToNextTask()` 시 `currentTaskIndex` 범위 | `InvariantViolationError` |

---

## 2. Value Object 검증 규칙

각 Value Object는 생성 시 자체 검증을 수행하여 유효하지 않은 값이 도메인에 진입하는 것을 차단한다.

### 2.1 GitUrl

| 항목 | 내용 |
|------|------|
| **타입** | `string` (branded type) |
| **규칙** | 유효한 URL 형식이어야 한다. 프로토콜은 `git://`, `https://`, `ssh://` 또는 `git@` 형식 |
| **정규식** | `/^(https?:\/\/|git:\/\/|ssh:\/\/|git@).+\.git$/` |
| **에러 메시지** | `"유효하지 않은 Git URL 형식입니다. https://, git://, ssh:// 또는 git@ 프로토콜을 사용하세요."` |

### 2.2 BranchName

| 항목 | 내용 |
|------|------|
| **타입** | `string` (branded type) |
| **규칙** | 공백 불가, `..` 불가, ASCII 제어 문자 불가, `~`, `^`, `:`, `?`, `*`, `[` 불가, `/`로 시작/끝 불가, `.lock`으로 끝 불가 |
| **정규식** | `/^(?!\/|.*(?:\/\/|\.\.|\/$|\.lock$|@\{))[\x21-\x7e]+$/` |
| **에러 메시지** | `"유효하지 않은 Git 브랜치 이름입니다. 공백, 연속 점(..), 제어 문자는 사용할 수 없습니다."` |

### 2.3 CommitHash

| 항목 | 내용 |
|------|------|
| **타입** | `string` (branded type) |
| **규칙** | 정확히 40자의 16진수 문자열 |
| **정규식** | `/^[0-9a-f]{40}$/` |
| **에러 메시지** | `"유효하지 않은 커밋 해시입니다. 40자리 16진수 문자열이어야 합니다."` |

### 2.4 IssueKey

| 항목 | 내용 |
|------|------|
| **타입** | `string` (branded type) |
| **규칙** | 프로젝트별 설정 가능한 패턴. 기본값은 JIRA 형식 |
| **기본 정규식** | `/^[A-Z]+-\d+$/` (예: `PROJ-123`, `AGENT-42`) |
| **설정** | `IssueKeyPattern`을 외부에서 주입하여 커스터마이즈 가능 |
| **에러 메시지** | `"유효하지 않은 이슈 키 형식입니다. '{pattern}' 패턴과 일치해야 합니다."` |

### 2.5 AgentModel

| 항목 | 내용 |
|------|------|
| **타입** | `string` (branded type 또는 enum) |
| **규칙** | 허용된 모델 식별자 목록(allowlist)에 포함되어야 한다 |
| **허용 목록 예시** | `claude-sonnet-4-20250514`, `claude-opus-4-20250514`, `gpt-4o`, `gpt-4o-mini` 등 |
| **설정** | `AgentModelRegistry`를 통해 런타임에 허용 목록 관리 |
| **에러 메시지** | `"지원하지 않는 AI 모델입니다: '{model}'. 허용된 모델: {allowedModels}"` |

### 2.6 McpTransportType

| 항목 | 내용 |
|------|------|
| **타입** | `enum` |
| **허용 값** | `STDIO`, `SSE`, `STREAMABLE_HTTP` |
| **에러 메시지** | `"지원하지 않는 MCP 전송 방식입니다. STDIO, SSE, STREAMABLE_HTTP 중 하나를 선택하세요."` |

### 2.7 ReportOutline

| 항목 | 내용 |
|------|------|
| **타입** | 복합 값 객체 (`{ sections: Section[] }`) |
| **규칙** | `sections` 배열이 비어있으면 안 됨. 각 `Section`의 `title`은 비어있으면 안 됨 |
| **에러 메시지** | `"ReportOutline은 최소 1개 이상의 섹션을 포함해야 합니다."` / `"섹션 제목은 비어있을 수 없습니다."` |

### 2.8 query (Task 프롬프트)

| 항목 | 내용 |
|------|------|
| **타입** | `string` |
| **규칙** | 비어있으면 안 됨 (최소 1자), 최대 50000자 |
| **에러 메시지** | `"쿼리는 비어있을 수 없습니다."` / `"쿼리는 50000자를 초과할 수 없습니다. (현재: {length}자)"` |

### 2.9 검증 규칙 요약 테이블

| Value Object | 타입 | 검증 규칙 | 에러 코드 |
|-------------|------|----------|----------|
| `GitUrl` | string | URL format + git 프로토콜 | `INVALID_GIT_URL` |
| `BranchName` | string | git ref 규칙 준수 | `INVALID_BRANCH_NAME` |
| `CommitHash` | string | `/^[0-9a-f]{40}$/` | `INVALID_COMMIT_HASH` |
| `IssueKey` | string | configurable pattern (default: `/^[A-Z]+-\d+$/`) | `INVALID_ISSUE_KEY` |
| `AgentModel` | string/enum | allowlist 포함 여부 | `UNSUPPORTED_AGENT_MODEL` |
| `McpTransportType` | enum | `STDIO \| SSE \| STREAMABLE_HTTP` | `INVALID_TRANSPORT_TYPE` |
| `ReportOutline` | object | `sections.length > 0`, 각 section.title 비어있지 않음 | `INVALID_REPORT_OUTLINE` |
| `query` | string | `1 <= length <= 50000` | `INVALID_QUERY` |

---

## 3. Command 검증 규칙

각 UseCase의 Command에 대한 검증 항목을 계층별로 정리한다.

### 3.1 Git Commands

| Command | Presentation 검증 | Application 검증 | Domain 검증 |
|---------|-------------------|------------------|-------------|
| `CreateGitCommand(url, localPath)` | `url`: 필수, string / `localPath`: 필수, string | (없음) | `GitUrl` 형식 검증 |
| `DeleteGit(gitId)` | `gitId`: 필수, string | Git 존재 확인 | `canDelete()` — activeWorkflowIds 비어있는지 |

### 3.2 McpServer Commands

| Command | Presentation 검증 | Application 검증 | Domain 검증 |
|---------|-------------------|------------------|-------------|
| `RegisterMcpServerCommand(name, command, args, env, transportType, url?)` | `name`: 필수, 비어있지 않음 / `command`: 필수 / `args`: string[] / `transportType`: enum 값 / `url`: SSE/STREAMABLE_HTTP일 때 필수 | `McpClient.validate()` 연결 검증 | `McpTransportType` enum 검증 |
| `UnregisterMcpServer(mcpServerId)` | `mcpServerId`: 필수, string | McpServer 존재 확인 | `canDelete()` — activeWorkflowIds 비어있는지 |

### 3.3 WorkflowTemplate Commands

| Command | Presentation 검증 | Application 검증 | Domain 검증 |
|---------|-------------------|------------------|-------------|
| `CreateWorkflowTemplateCommand(name, desc, workDefs, gitRefs, mcpServerRefs)` | `name`: 필수, 비어있지 않음 / `workDefinitions`: 비어있지 않은 배열 / 각 `taskDefinition.query`: 1~50000자 | 모든 `gitId` 존재 / 모든 `mcpServerId` 존재 | `ReportOutline` 검증 / `AgentModel` allowlist / `query` 길이 |
| `CreateTemplateFromWorkflowCommand(workflowId, name, desc)` | `workflowId`: 필수 / `name`: 필수, 비어있지 않음 | Workflow 존재 확인 | (없음) |
| `UpdateWorkflowTemplateCommand(templateId, ...)` | 부분 업데이트 가능, 제공된 필드만 검증 | Template 존재 / 변경된 gitId/mcpServerId 존재 | 변경된 값에 대한 VO 검증 |
| `DeleteWorkflowTemplate(templateId)` | `templateId`: 필수 | Template 존재 확인 | (없음) |

### 3.4 Workflow Commands

| Command | Presentation 검증 | Application 검증 | Domain 검증 |
|---------|-------------------|------------------|-------------|
| `CreateWorkflowCommand(templateId, issueKey, workBranch)` | `templateId`: 필수 / `issueKey`: 필수, string / `workBranch`: 필수, string | Template 존재 / gitRefs의 Git 존재 | `IssueKey` 형식 / `BranchName` 형식 |
| `StartWorkflow(workflowId)` | `workflowId`: 필수 | Workflow 존재 | `canStart()` — READY 상태 |
| `PauseWorkflow(workflowId)` | `workflowId`: 필수 | Workflow 존재 | `canPause()` — RUNNING 상태 |
| `ResumeWorkflowCommand(workflowId, checkpointId?)` | `workflowId`: 필수 / `checkpointId`: 선택 | Workflow 존재 / Checkpoint 유효성 (있는 경우) | `canResume()` — PAUSED 또는 FAILED |
| `CancelWorkflow(workflowId)` | `workflowId`: 필수 | Workflow 존재 | `canCancel()` — READY/RUNNING/PAUSED/RESUMING |
| `DeleteWorkflow(workflowId)` | `workflowId`: 필수 | Workflow 존재 | `canDelete()` — CREATED/COMPLETED/FAILED/CANCELLED |

### 3.5 Work Commands

| Command | Presentation 검증 | Application 검증 | Domain 검증 |
|---------|-------------------|------------------|-------------|
| `StartNextWork(workflowId)` | (내부 이벤트 트리거) | Workflow 존재 / RUNNING 또는 RESUMING 상태 | (없음) |
| `ReorderWorks(workflowId, newOrder)` | `newOrder`: WorkId[] 비어있지 않음 | Workflow 존재 / newOrder의 모든 WorkId가 Workflow에 속함 | `canModify()` — CREATED/READY/PAUSED/FAILED |

### 3.6 Task Commands

| Command | Presentation 검증 | Application 검증 | Domain 검증 |
|---------|-------------------|------------------|-------------|
| `SendQuery(workId)` | (내부 이벤트 트리거) | Work 존재 / Agent RUNNING 상태 | `currentTaskIndex` 범위 내 |
| `CompleteTask(workId, taskId)` | (내부 이벤트 트리거) | Work 존재 / Task가 해당 Work에 속함 | Task 상태가 완료 가능한 상태 |

### 3.7 Modify Commands

| Command | Presentation 검증 | Application 검증 | Domain 검증 |
|---------|-------------------|------------------|-------------|
| `AddTask(workflowId, workId, order, query, reportOutline?)` | `query`: 1~50000자 / `order`: 양수 | Workflow/Work 존재 | `canModify()` / `query` VO / `ReportOutline` VO |
| `RemoveTask(workflowId, workId, taskId)` | 모든 ID 필수 | Workflow/Work/Task 존재 | `canModify()` / Task 최소 1개 유지 |
| `UpdateTask(workflowId, workId, taskId, newQuery)` | `newQuery`: 1~50000자 | Workflow/Work/Task 존재 | `canModify()` / `query` VO |
| `ReorderTasks(workflowId, workId, newOrder)` | `newOrder`: TaskId[] 비어있지 않음 | Workflow/Work 존재 / 모든 TaskId가 Work에 속함 | `canModify()` |
| `UpdateGitRefs(workflowId, newGitRefs)` | `newGitRefs`: 비어있지 않은 배열 / gitId 중복 불가 | Workflow 존재 / 모든 gitId 존재 | `canModify()` / 최소 1개 GitRef |
| `UpdateMcpServerRefs(workflowId, newMcpServerRefs)` | `newMcpServerRefs`: 배열 | Workflow 존재 / 모든 mcpServerId 존재 | `canModify()` |

---

## 4. 테스트 전략 피라미드

```
         ╱╲
        ╱ E2E ╲           소수의 핵심 시나리오
       ╱────────╲
      ╱ Contract  ╲        Port 인터페이스 준수
     ╱──────────────╲
    ╱  Integration    ╲     UseCase + Repository + Event
   ╱────────────────────╲
  ╱      Unit Test        ╲  Aggregate, VO, State Machine
 ╱──────────────────────────╲
```

### 4.1 Unit Test — 도메인 모델 검증

**범위**: Domain Layer의 Aggregate, Value Object, Domain Service를 외부 의존성 없이 테스트한다.

| 테스트 대상 | 테스트 내용 | 예시 |
|------------|-----------|------|
| Value Object 생성 | 유효/무효 값에 대한 생성 성공/실패 | `GitUrl.create("https://github.com/repo.git")` 성공, `GitUrl.create("invalid")` 실패 |
| Aggregate 상태 전이 | 허용된 전이 성공, 불허 전이 실패 | `workflow.start()` — READY에서 성공, RUNNING에서 실패 |
| Aggregate 불변식 | 불변식 위반 시 예외 발생 | `git.delete()` — activeWorkflowIds가 비어있지 않으면 실패 |
| 파생 상태 계산 | `computedStatus()`가 올바른 값 반환 | Work의 모든 Task COMPLETED → `computedStatus() === COMPLETED` |
| Domain Event 발행 | 상태 변경 시 적절한 이벤트 생성 | `workflow.start()` → `WorkflowStarted` 이벤트 포함 |

**특징**: 외부 의존성 없음, 실행 속도 최상, 가장 많은 수의 테스트 케이스

### 4.2 Integration Test — UseCase + Repository + Event Handler

**범위**: UseCase가 Repository(In-Memory)와 Event Handler를 통해 올바르게 동작하는지 검증한다.

| 테스트 대상 | 테스트 내용 | 의존성 |
|------------|-----------|--------|
| UseCase 실행 | Command → Aggregate 변경 → 저장 → 이벤트 발행 | In-Memory Repository, Event Spy |
| Event Handler 체인 | 이벤트 발행 → 핸들러 실행 → 후속 UseCase 트리거 | In-Memory Repository, Fake Infrastructure |
| 다중 Aggregate 조율 | Workflow 생성 시 Work/Task/Report 함께 생성 | In-Memory Repository |
| 캐스케이딩 삭제 | Git 삭제 → WorkflowTemplate의 gitRef 제거 | In-Memory Repository |

**특징**: Infrastructure Port를 In-Memory/Fake로 대체, 이벤트 체인 검증 가능

### 4.3 E2E Test — REST API 전체 흐름

**범위**: HTTP 요청부터 최종 상태 변경 및 사이드 이펙트까지 전체 흐름을 검증한다.

| 테스트 대상 | 테스트 내용 | 의존성 |
|------------|-----------|--------|
| REST API → UseCase | HTTP 요청 → DTO 검증 → UseCase 실행 → 응답 | 전체 스택 (Fake Infrastructure) |
| 이벤트 기반 흐름 | Workflow 시작 → Work 실행 → Task 완료 → Checkpoint 생성 | Fake GitClient, Fake AgentClient |
| 에러 응답 | 유효하지 않은 요청 → 적절한 HTTP 상태 코드 및 에러 메시지 | 전체 스택 |
| WebSocket 알림 | 상태 변경 시 클라이언트에 실시간 알림 전달 | WebSocket Client |

**특징**: 실제 HTTP 호출, 전체 파이프라인 검증, 실행 속도 최하

### 4.4 Contract Test — Port 인터페이스 준수

**범위**: Infrastructure Adapter가 Port 인터페이스의 계약(contract)을 준수하는지 검증한다. 하나의 테스트 스위트를 작성하면 모든 Adapter 구현체에 대해 재사용할 수 있다.

| 테스트 대상 | 테스트 내용 | 검증 방식 |
|------------|-----------|----------|
| Repository Adapter | `save` → `findById` 왕복, `delete` 후 `findById` null | 공유 테스트 스위트 |
| GitClient Adapter | `clone` → `createWorktree` → `commit` → `getCurrentCommit` | 공유 테스트 스위트 |
| EventPublisher Adapter | `publish` 호출 시 등록된 핸들러에 이벤트 전달 | 공유 테스트 스위트 |

```typescript
// Contract Test 예시: Repository 공유 테스트 스위트
function repositoryContractTests<T>(
  repoFactory: () => Repository<T>,
  entityFactory: () => T
) {
  it("save 후 findById로 조회 가능", async () => {
    const repo = repoFactory();
    const entity = entityFactory();
    await repo.save(entity);
    const found = await repo.findById(entity.id);
    expect(found).toEqual(entity);
  });

  it("delete 후 findById 결과 null", async () => {
    const repo = repoFactory();
    const entity = entityFactory();
    await repo.save(entity);
    await repo.delete(entity);
    const found = await repo.findById(entity.id);
    expect(found).toBeNull();
  });
}
```

---

## 5. 테스트 인프라

### 5.1 In-Memory Repository

모든 Repository Port에 대한 In-Memory 구현체를 제공한다. Unit Test와 Integration Test에서 사용한다.

| Repository | 내부 저장소 | 특수 구현 |
|-----------|-----------|----------|
| `InMemoryGitRepository` | `Map<GitId, Git>` | `findByUrl`: url 필드 비교 |
| `InMemoryWorkflowRepository` | `Map<WorkflowId, Workflow>` | `findByStatus`: status 필터링, `findByGitId`: gitRefs 내 gitId 검색 |
| `InMemoryWorkRepository` | `Map<WorkId, Work>` | `findByWorkflowId`: workflowId 필터링, `findByTaskId`: tasks 내 taskId 검색 |
| `InMemoryReportRepository` | `Map<ReportId, Report>` | `findByTaskId`, `findByWorkflowId` |
| `InMemoryCheckpointRepository` | `Map<CheckpointId, Checkpoint>` | `findByWorkflowId`, `findLatestByWorkId`: createdAt 기준 정렬 |
| `InMemoryWorkTreeRepository` | `Map<WorkTreeId, WorkTree>` | `findByWorkflowIdAndGitId`: 복합 조건 |
| `InMemoryWorkflowSpaceRepository` | `Map<WorkflowSpaceId, WorkflowSpace>` | `findByWorkflowId` |
| `InMemoryWorkflowTemplateRepository` | `Map<WorkflowTemplateId, WorkflowTemplate>` | `findByGitId`: gitRefs 내 검색, `findByMcpServerId`: mcpServerRefs + workDefinitions 내 검색 |
| `InMemoryMcpServerRepository` | `Map<McpServerId, McpServer>` | 기본 CRUD |

### 5.2 Test Fixtures & Builders

테스트 데이터 생성을 위한 Builder 패턴을 제공한다. 필수 필드에 기본값을 설정하고, 필요한 필드만 오버라이드할 수 있다.

```typescript
// WorkflowBuilder 예시
class WorkflowBuilder {
  private props = {
    id: WorkflowId.generate(),
    issueKey: IssueKey.create("TEST-1"),
    branchStrategy: { workBranch: BranchName.create("feature/test") },
    gitRefs: [{ gitId: GitId.generate(), baseBranch: BranchName.create("main") }],
    mcpServerRefs: [],
    workIds: [],
    workSequences: new Map(),
    workTreeStatuses: new Map(),
    workStatuses: new Map(),
    status: WorkflowStatus.CREATED,
  };

  withStatus(status: WorkflowStatus) { this.props.status = status; return this; }
  withGitRefs(refs: GitRef[]) { this.props.gitRefs = refs; return this; }
  withWorkIds(ids: WorkId[]) { this.props.workIds = ids; return this; }
  build(): Workflow { return Workflow.reconstitute(this.props); }
}
```

| Builder | 기본값 | 주요 오버라이드 |
|---------|-------|---------------|
| `WorkflowBuilder` | CREATED 상태, 기본 GitRef 1개 | `withStatus()`, `withGitRefs()`, `withWorkIds()` |
| `WorkBuilder` | PENDING 상태, 기본 Task 1개 | `withTasks()`, `withSequence()`, `withModel()` |
| `TaskBuilder` | PENDING 상태, 기본 query | `withQuery()`, `withReportOutline()` |
| `GitBuilder` | 빈 activeWorkflowIds | `withActiveWorkflowIds()`, `withUrl()` |
| `McpServerBuilder` | STDIO transport, 빈 activeWorkflowIds | `withTransportType()`, `withUrl()` |
| `CheckpointBuilder` | 기본 commitHashes | `withWorkSequence()`, `withCommitHashes()` |
| `WorkflowTemplateBuilder` | 기본 WorkDefinition 1개 | `withWorkDefinitions()`, `withGitRefs()` |
| `ReportBuilder` | PENDING 상태, 기본 outline | `withOutline()`, `withStatus()` |

### 5.3 Event Spy / Mock

이벤트 발행을 캡처하여 검증에 사용하는 테스트 도구를 제공한다.

```typescript
class EventSpy implements EventPublisher {
  private publishedEvents: DomainEvent[] = [];

  async publish(event: DomainEvent): Promise<void> {
    this.publishedEvents.push(event);
  }

  getEvents(): DomainEvent[] { return [...this.publishedEvents]; }
  getEventsByType<T>(type: string): T[] {
    return this.publishedEvents.filter(e => e.type === type) as T[];
  }
  hasEvent(type: string): boolean {
    return this.publishedEvents.some(e => e.type === type);
  }
  clear(): void { this.publishedEvents = []; }
}
```

### 5.4 Fake Infrastructure Clients

외부 시스템 연동을 시뮬레이션하는 Fake 구현체를 제공한다.

| Fake Client | 시뮬레이션 대상 | 주요 동작 |
|-------------|--------------|----------|
| `FakeGitClient` | Git CLI 작업 | clone/worktree/branch/commit을 메모리 내에서 시뮬레이션. `getCurrentCommit`은 deterministic hash 반환 |
| `FakeAgentClient` | AI Agent 프로세스 | `start()` 호출 시 `AgentStarted` 이벤트 자동 발행. `sendQuery()` 호출 시 configurable 응답 반환 |
| `FakeMcpClient` | MCP 서버 연결 | `validate()`는 항상 성공 (또는 에러 시나리오 설정 가능). `listTools()`는 configurable 도구 목록 반환 |
| `FakeFileSystem` | 파일시스템 작업 | 메모리 내 디렉토리/파일/symlink 트리 관리. `exists()` 검증 가능 |

```typescript
// FakeGitClient 예시
class FakeGitClient implements GitClient {
  private repos = new Map<string, FakeRepo>();
  private commitCounter = 0;

  async clone(url: GitUrl, path: string): Promise<void> {
    this.repos.set(path, { url, branches: ["main"], worktrees: [] });
  }

  async commit(worktreePath: string, message: string): Promise<CommitHash> {
    this.commitCounter++;
    const hash = this.commitCounter.toString(16).padStart(40, "0");
    return CommitHash.create(hash);
  }

  // 에러 시나리오 설정
  private errors = new Map<string, Error>();
  simulateError(method: string, error: Error): void {
    this.errors.set(method, error);
  }
}
```

---

## 6. 주요 테스트 시나리오

### 6.1 정상 Workflow 실행 E2E

| 단계 | 동작 | 검증 항목 |
|------|------|----------|
| 1 | `POST /git` — Git 등록 | Git 생성 완료, `GitCreated` 이벤트 |
| 2 | `POST /mcp-servers` — MCP 서버 등록 | McpServer 생성 완료, `McpServerRegistered` 이벤트 |
| 3 | `POST /templates` — Template 생성 (Work 2개, Task 각 1개) | Template 저장, gitRef/mcpServerRef 참조 검증 |
| 4 | `POST /workflows` — Workflow 생성 | Workflow + Work + Task + Report 생성, 상태 CREATED |
| 5 | `POST /workflows/{id}/start` | CREATED → PREPARING → READY → RUNNING 전이 |
| 6 | (자동) `WorkflowStarted` → `StartNextWork` → `WorkStarted` → `SendQuery` | Work-0 Agent 시작, Task-0 Query 전송 |
| 7 | (자동) `QueryResponded` → `CompleteTask` → `WorkCompleted` | Task 완료, Work-0 완료, Checkpoint 생성 |
| 8 | (자동) `StartNextWork` → Work-1 동일 흐름 | Work-1 실행 및 완료 |
| 9 | (자동) `WorkflowCompleted` | 모든 Work 완료, Workflow COMPLETED, Git 사용 해제 |

### 6.2 Resume from Checkpoint

| 단계 | 동작 | 검증 항목 |
|------|------|----------|
| 1 | Workflow 시작 → Work-0 완료 → Checkpoint-0 생성 | Checkpoint에 commitHashes 저장 |
| 2 | Work-1 실행 중 Agent Error 발생 | Workflow FAILED 상태 |
| 3 | `POST /workflows/{id}/resume` (Auto) | 마지막 유효 Checkpoint(Checkpoint-0) 탐색 |
| 4 | Git reset to Checkpoint-0 commitHashes | 각 WorkTree가 Checkpoint 시점으로 복원 |
| 5 | Work-1 이후 WorkSpace/Report 정리 | 파일시스템 정리 확인 |
| 6 | Work-1 reset → PENDING, Workflow RESUMING → RUNNING | 상태 전이 검증 |
| 7 | Work-1 재실행 → 정상 완료 | Workflow COMPLETED |

### 6.3 Concurrent Modification

| 단계 | 동작 | 검증 항목 |
|------|------|----------|
| 1 | Workflow RUNNING 상태 | 진행 중인 상태 확인 |
| 2 | `ModifyWorkflow.AddTask` 호출 | `canModify()` 실패 → `409 Conflict` 반환 |
| 3 | `PauseWorkflow` 호출 → PAUSED | 상태 전이 성공 |
| 4 | `ModifyWorkflow.AddTask` 재호출 | PAUSED 상태에서 `canModify()` 성공 |
| 5 | Task 추가 확인 | Work 내 Task 목록 업데이트 |

### 6.4 GitRef 추가/제거 캐스케이딩

| 단계 | 동작 | 검증 항목 |
|------|------|----------|
| 1 | Workflow PAUSED 상태, GitRef 2개 (Git-A, Git-B) | WorkTree 2개 존재 |
| 2 | `UpdateGitRefs` — Git-B 제거, Git-C 추가 | delta 계산 정확성 |
| 3 | Git-B WorkTree 삭제 | WorkTree 삭제, `workTreeStatuses`에서 Git-B 제거, `Git-B.removeWorkflow()` |
| 4 | Git-C WorkTree 생성 (PAUSED 상태이므로 즉시 생성) | WorkTree READY, `workTreeStatuses`에 Git-C 추가, `Git-C.addWorkflow()` |
| 5 | 기존 Checkpoint의 Git-B commitHash | 이력 보존 (삭제되지 않음) |
| 6 | Resume 시 Git-C는 base branch로 reset | Checkpoint에 Git-C 항목 없으므로 base 사용 |

### 6.5 Agent Error → WorkflowFailed → Resume

| 단계 | 동작 | 검증 항목 |
|------|------|----------|
| 1 | Work-1 실행 중 `AgentError` 이벤트 수신 | `AgentErrorHandler` 트리거 |
| 2 | Work-1 agentStatus → ERROR | `WorkStatusChanged(FAILED)` 발행 |
| 3 | `WorkflowFailed` 이벤트 발행 | Workflow status → FAILED |
| 4 | `ResumeWorkflow(Auto)` | `canResume()` 성공 (FAILED 상태) |
| 5 | Checkpoint 기반 rollback | Git reset 수행 |
| 6 | Work-1 reset → PENDING | 재실행 준비 |
| 7 | Workflow RESUMING → RUNNING → Work-1 재시작 | Agent 재시작, Query 재전송 |

### 6.6 전역 리소스 삭제 캐스케이딩

| 단계 | 동작 | 검증 항목 |
|------|------|----------|
| 1 | Git-A를 참조하는 Template 2개 존재 | Template-1: gitRefs [Git-A, Git-B], Template-2: gitRefs [Git-A] |
| 2 | Git-A에 activeWorkflow 없음 확인 | `canDelete()` 성공 |
| 3 | `DeleteGit(Git-A)` | Git 삭제 |
| 4 | Template-1의 gitRefs → [Git-B] | Git-A 참조 제거, Template 유지 |
| 5 | Template-2의 gitRefs → [] | Git-A 참조 제거, Template 유지 (빈 gitRefs) |
| 6 | `GitDeleted` 이벤트 발행 | 이벤트 페이로드 검증 |

### 6.7 McpServer 삭제 캐스케이딩

| 단계 | 동작 | 검증 항목 |
|------|------|----------|
| 1 | McpServer-A를 참조하는 Template 존재 (전역 + WorkDefinition 내부) | 전역 mcpServerRefs [McpServer-A], WorkDef-0 mcpServerRefs [McpServer-A] |
| 2 | `UnregisterMcpServer(McpServer-A)` | McpServer 삭제 |
| 3 | Template 전역 mcpServerRefs에서 McpServer-A 제거 | 전역 참조 제거 확인 |
| 4 | Template WorkDef-0 mcpServerRefs에서 McpServer-A 제거 | WorkDefinition 내부 참조도 제거 확인 |

---

## 7. 불변식 테스트 체크리스트

### 7.1 Git Aggregate

| 불변식 | 테스트 케이스 | 기대 결과 |
|--------|------------|----------|
| activeWorkflowIds가 비어있어야만 삭제 가능 | `canDelete()` — activeWorkflowIds 비어있음 | `true` |
| | `canDelete()` — activeWorkflowIds에 1개 이상 | `false` |
| | `delete()` — activeWorkflowIds 비어있지 않을 때 호출 | `InvariantViolationError` |
| addWorkflow는 idempotent | `addWorkflow(wfId)` 2회 호출 | Set 크기 1 유지 |
| removeWorkflow는 없는 ID에 대해 안전 | `removeWorkflow(존재하지_않는_id)` | 예외 없음, 상태 변화 없음 |

### 7.2 McpServer Aggregate

| 불변식 | 테스트 케이스 | 기대 결과 |
|--------|------------|----------|
| activeWorkflowIds가 비어있어야만 삭제 가능 | Git과 동일한 패턴 | Git과 동일 |
| SSE/STREAMABLE_HTTP일 때 url 필수 | `create(transportType: SSE, url: null)` | `InvariantViolationError` |
| STDIO일 때 url 무시 | `create(transportType: STDIO, url: "http://...")` | url 무시 또는 null 처리 |

### 7.3 Workflow Aggregate

| 불변식 | 테스트 케이스 | 기대 결과 |
|--------|------------|----------|
| `start()`: READY 상태에서만 가능 | 각 상태에서 `start()` 호출 | READY: 성공, 나머지: `InvalidStateTransitionError` |
| `pause()`: RUNNING 상태에서만 가능 | 각 상태에서 `pause()` 호출 | RUNNING: 성공, 나머지: 실패 |
| `resume()`: PAUSED 또는 FAILED에서만 가능 | 각 상태에서 `resume()` 호출 | PAUSED/FAILED: 성공, 나머지: 실패 |
| `cancel()`: READY/RUNNING/PAUSED/RESUMING에서 가능 | 각 상태에서 `cancel()` 호출 | 4개 상태: 성공, 나머지: 실패 |
| `delete()`: CREATED/COMPLETED/FAILED/CANCELLED에서 가능 | 각 상태에서 `delete()` 호출 | 4개 상태: 성공, 나머지: 실패 |
| `modify()`: CREATED/READY/PAUSED/FAILED에서 가능 | 각 상태에서 `modify()` 호출 | 4개 상태: 성공, 나머지: 실패 |
| gitRefs는 최소 1개 유지 | `updateGitRefs([])` | `InvariantViolationError` |
| workTreeStatuses와 gitRefs 일관성 | GitRef 추가 시 workTreeStatuses 항목 추가 | 일관성 유지 |

### 7.4 Work Aggregate (Task 포함)

| 불변식 | 테스트 케이스 | 기대 결과 |
|--------|------------|----------|
| `currentTaskIndex`가 tasks 범위 내 | `advanceToNextTask()` — 마지막 Task 이후 | `currentTaskIndex === tasks.length` (완료 상태) |
| | `currentTask()` — index가 범위 밖 | `null` 반환 또는 예외 |
| tasks는 최소 1개 | Task 모두 제거 시도 | `InvariantViolationError` |
| Task order 유일성 | 동일 order로 Task 추가 | 기존 Task 밀어내기 또는 에러 |
| Agent IDLE → STARTING → RUNNING 전이 | 잘못된 순서의 agentStatus 전이 | `InvalidStateTransitionError` |
| PENDING Work만 시작 가능 | COMPLETED/FAILED Work에 `startAgent()` | 실패 |

### 7.5 Checkpoint Aggregate

| 불변식 | 테스트 케이스 | 기대 결과 |
|--------|------------|----------|
| workSequence가 현재 Workflow의 Work 순서와 일치해야 유효 | Work reorder 후 기존 Checkpoint 조회 | 유효하지 않은 Checkpoint 필터링 |
| commitHashes가 비어있지 않음 | `create(commitHashes: empty)` | `InvariantViolationError` |
| workSequence >= 0 | `create(workSequence: -1)` | `InvariantViolationError` |

### 7.6 WorkTree Aggregate

| 불변식 | 테스트 케이스 | 기대 결과 |
|--------|------------|----------|
| 상태 전이: PENDING → CREATING → READY | 정상 생성 흐름 | 순차 전이 성공 |
| 상태 전이: CREATING → FAILED | 생성 실패 | FAILED 상태 전이 |
| READY에서만 RELEASED 가능 | PENDING에서 release 시도 | `InvalidStateTransitionError` |

### 7.7 WorkflowTemplate Aggregate

| 불변식 | 테스트 케이스 | 기대 결과 |
|--------|------------|----------|
| workDefinitions 비어있지 않음 | `create(workDefinitions: [])` | `InvariantViolationError` |
| 각 WorkDefinition에 taskDefinitions 비어있지 않음 | WorkDefinition에 빈 taskDefinitions | `InvariantViolationError` |
| `removeGitRef` 캐스케이딩 | `removeGitRef(gitId)` | gitRefs에서 해당 항목 제거 |
| `removeMcpServerRef` 캐스케이딩 | `removeMcpServerRef(mcpServerId)` | 전역 + WorkDefinition 내부 모두 제거 |

### 7.8 WorkflowSpace Aggregate

| 불변식 | 테스트 케이스 | 기대 결과 |
|--------|------------|----------|
| 상태 전이: PENDING → CREATED → ACTIVE → RELEASED | 정상 흐름 | 순차 전이 성공 |
| WorkSpace의 workId 유일성 | 동일 workId로 WorkSpace 중복 추가 | `InvariantViolationError` 또는 교체 |
| SymLink targetPath 유효성 | 빈 targetPath로 SymLink 생성 | `InvariantViolationError` |

---

## 8. 에러 코드 체계

테스트에서 검증할 에러 코드의 분류 체계이다.

| 에러 분류 | 코드 접두사 | HTTP 상태 | 예시 |
|-----------|-----------|----------|------|
| 형식 검증 실패 | `VALIDATION_*` | 400 | `VALIDATION_INVALID_GIT_URL`, `VALIDATION_INVALID_QUERY` |
| 엔티티 없음 | `NOT_FOUND_*` | 404 | `NOT_FOUND_GIT`, `NOT_FOUND_WORKFLOW` |
| 상태 충돌 | `CONFLICT_*` | 409 | `CONFLICT_CANNOT_START`, `CONFLICT_CANNOT_DELETE` |
| 불변식 위반 | `INVARIANT_*` | 422 | `INVARIANT_EMPTY_WORK_DEFINITIONS`, `INVARIANT_TASK_INDEX_OUT_OF_BOUNDS` |
| 외부 시스템 실패 | `EXTERNAL_*` | 502 | `EXTERNAL_GIT_CLONE_FAILED`, `EXTERNAL_AGENT_START_FAILED` |

---

## 관련 문서
- [01-서비스-개요.md](01-서비스-개요.md) — 시스템 전체 개요 및 레이어 구조
- [02-도메인-모델.md](02-도메인-모델.md) — Aggregate, Value Object, 불변식 상세
- [03-유스케이스.md](03-유스케이스.md) — Command 상세 및 검증 흐름
- [04-이벤트-흐름.md](04-이벤트-흐름.md) — 이벤트 핸들러 체인 (테스트 시나리오 기반)
- [05-인프라스트럭처.md](05-인프라스트럭처.md) — Port 인터페이스 및 Adapter 구현
