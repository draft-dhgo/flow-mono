Choreography의 이론적 장점은 "각 모듈이 서로를 모른다"는 건데, 현실에서는 그게 허상에 가깝습니다. Inventory 모듈이 `PaymentFailed` 이벤트를 구독해서 재고를 복구한다면, 그건 결국 **결제 실패라는 맥락을 알고 있다**는 겁니다. 이벤트 이름과 페이로드를 통해 암묵적으로 다른 모듈의 존재와 흐름을 인지하고 있는 셈이죠. 직접 의존이 간접 의존으로 바뀌었을 뿐, 인지 비용이 사라진 게 아닙니다.

오히려 더 나쁜 점은 그 인지가 **코드 전체에 흩어진다**는 겁니다. Orchestration은 흐름이 한 곳에 모여 있어서 "이 유스케이스에서 무슨 일이 일어나는가"를 파일 하나만 보면 됩니다. Choreography는 각 모듈의 이벤트 핸들러를 전부 추적해야 전체 그림이 그려집니다.

특히 모듈라 모놀리스에서는 Orchestration의 단점이 거의 없습니다. 마이크로서비스에서 Orchestrator가 부담이 되는 이유는 네트워크 호출, 장애 전파, 단일 실패 지점 같은 분산 환경의 문제 때문인데, 같은 프로세스 안에서는 그냥 메서드 호출이라 이런 문제가 대부분 해소됩니다.

Choreography가 빛나는 건 **흐름에 참여하는 모듈이 동적으로 늘어나는 경우**입니다. "주문 생성 시 알림도 보내고, 포인트도 적립하고, 분석 로그도 남기고..." 같은 부가 기능이 계속 추가되는데 핵심 흐름을 건드리고 싶지 않을 때요. 이런 건 보상 트랜잭션이 필요 없는 fire-and-forget 성격이라 choreography가 자연스럽습니다.

정리하면, **보상이 필요한 핵심 비즈니스 흐름은 Orchestration**, **보상 없이 반응만 하면 되는 부가 기능은 이벤트 구독** — 이렇게 나누는 게 실용적입니다.