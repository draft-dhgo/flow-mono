워크플로우 실행 UX 개선: Task별 실행 상태, 구조화 리포트, 타임라인, 에이전트 사고과정, 템플릿 시스템을 구현한다.
현재 리포트는 flat markdown이고 Task 단위 실행 상태가 안 보이며 에이전트 사고 과정이 드러나지 않는다.
flow-front/CLAUDE.md와 flow-backend/CLAUDE.md의 모든 규칙을 준수한다.

수정 범위:
  1. 백엔드 도메인: WorkExecution/TaskExecution에 타임스탬프 추가, AgentLogEntry에 phase 필드 추가
  2. 백엔드 API: WorkExecution 상세 조회 엔드포인트, 구조화 리포트 엔드포인트, 로그 phase 직렬화
  3. 백엔드 신규 모듈: task-template 바운디드 컨텍스트 전체
  4. 프론트엔드 타입/API: 응답 타입 동기화, 신규 API 클라이언트 함수
  5. 프론트엔드 UI: Task 상태 표시, 타임라인, 구조화 리포트 뷰어, 에이전트 phase 표시, 템플릿 선택기

수정 금지:
  - docs/ 디렉토리의 설계 문서
  - README.md
  - 기존 도메인 로직의 비즈니스 규칙 변경 -- 필드 추가만 허용
  - 기존 API의 하위호환 깨트리기 -- 새 엔드포인트를 추가하되 기존은 유지

아래 7개 Phase를 순서대로 진행한다.
각 Phase 완료 후 반드시 아래 검증을 실행한다. 검증 실패 시 수정 후 다시 검증한다. 검증 통과 후 다음 Phase로 진행한다.
  백엔드 검증: cd flow-backend && npm run typecheck && npm run test && npm run lint
  프론트엔드 검증: cd flow-front && npx tsc -b && npm run lint && npm run build
각 Phase 완료 후 Playwright MCP를 통해 localhost:5173에 접속하여 실제 화면을 확인하고 문제가 있으면 즉시 수정한다.


----- Phase 1 백엔드 도메인 레이어 변경 -----

핵심 파일:
  - flow-backend/src/workflow-runtime/domain/entities/task-execution.ts
  - flow-backend/src/workflow-runtime/domain/entities/work-execution.ts
  - flow-backend/src/agent/application/agent-log-entry.ts
  - flow-backend/src/agent/infra/claude-agent-client.ts
  - flow-backend/src/agent/application/agent-log-emitter.ts
참조할 코드 -- 읽기만, 수정하지 않음:
  - flow-backend/src/workflow-runtime/domain/entities/report.ts -- Report 엔티티 구조 참조
  - flow-backend/src/common/aggregate-root.ts -- AggregateRoot 베이스 클래스

1-1. TaskExecution에 타임스탬프 필드 추가
     task-execution.ts를 수정한다.
     TaskExecutionProps 인터페이스에 다음 필드를 추가한다:
       startedAt 필드 -- 타입은 Date 또는 null
       completedAt 필드 -- 타입은 Date 또는 null
     CreateTaskExecutionProps에는 추가하지 않는다 -- 생성 시에는 null로 초기화.
     private 필드 추가:
       private _startedAt: Date 또는 null
       private _completedAt: Date 또는 null
     constructor에서 props.startedAt, props.completedAt 할당.
     create 정적 메서드에서 startedAt: null, completedAt: null로 초기화.
     getter 추가: get startedAt, get completedAt
     markCompleted 메서드 수정: 기존 this._isCompleted = true 외에 this._completedAt = new Date 추가.
     markStarted 메서드 신규: this._startedAt = new Date 설정.
     reset 메서드 수정: 기존 초기화 외에 this._startedAt = null, this._completedAt = null 추가.

1-2. WorkExecution에 타임스탬프 필드 추가
     work-execution.ts를 수정한다.
     WorkExecutionProps 인터페이스에 다음 필드를 추가한다:
       startedAt 필드 -- 타입은 Date
       completedAt 필드 -- 타입은 Date 또는 null
     CreateWorkExecutionProps에는 추가하지 않는다.
     private 필드 추가:
       private _startedAt: Date
       private _completedAt: Date 또는 null
     constructor에서 할당.
     create 정적 메서드에서 startedAt: new Date, completedAt: null로 초기화.
     또한 create 내에서 첫 번째 taskExecution의 markStarted 호출.
     getter 추가: get startedAt, get completedAt
     advanceToNextTask 메서드 수정:
       isCompleted가 true가 될 때 this._completedAt = new Date 추가.
       다음 task로 이동할 때 -- this._currentTaskIndex++ 직후 -- 새 currentTask의 markStarted 호출.
     cancel 메서드 수정: this._completedAt = new Date 추가.
     reset 메서드 수정: this._completedAt = null 추가.

1-3. AgentLogEntry에 phase 필드 추가
     agent-log-entry.ts를 수정한다.
     AgentLogPhase 타입을 새로 정의한다: thinking 또는 executing 또는 reporting 또는 error
     AgentLogEntry 인터페이스에 phase 필드 추가 -- 타입은 AgentLogPhase, 옵셔널.
     createAgentLogEntry 팩토리 함수의 파라미터에 phase를 옵셔널로 추가.
     반환 객체에 phase 포함.

1-4. AgentLogEmitter에 phase 전달 지원
     agent-log-emitter.ts를 수정한다.
     bufferEntry 메서드의 파라미터에 phase를 옵셔널로 추가.
     createAgentLogEntry 호출 시 phase를 전달.
     emitDirect 메서드의 파라미터에도 phase를 옵셔널로 추가.
     createAgentLogEntry 호출 시 phase를 전달.

1-5. ClaudeAgentClient에서 phase 분류 로직 추가
     claude-agent-client.ts를 수정한다.
     클래스에 private _hasSeenToolUse 필드 추가 -- 타입은 boolean, 초기값 false.
     sendQuery 시작 시 this._hasSeenToolUse = false로 리셋.

     emitLogFromMessage 메서드 수정:
       system_init 엔트리의 phase를 thinking으로 설정.
       assistant_text 엔트리: this._hasSeenToolUse가 false이면 thinking, true이면 executing으로 설정.
       tool_use 엔트리: phase를 executing으로 설정. this._hasSeenToolUse = true.
       tool_result 엔트리: phase를 executing으로 설정.
       result_summary 엔트리: phase를 reporting으로 설정.

     emitLogDirect 메서드 동일 로직:
       system_init 항목의 phase를 thinking으로
       assistant 메시지 내 content block 처리 시:
         text block: _hasSeenToolUse가 false이면 thinking, true이면 executing
         tool_use block: executing, _hasSeenToolUse = true
         tool_result block: executing
       result_summary 항목의 phase를 reporting으로

     emitContentBlocks 메서드 수정:
       각 block의 bufferEntry 호출 시 phase 전달.
       text block: _hasSeenToolUse 기반 thinking 또는 executing
       tool_use block: executing, _hasSeenToolUse = true
       tool_result block: executing

     emitDirectBlock 메서드 수정:
       각 block의 emitDirect 호출 시 phase 전달.
       동일 분류 로직 적용.

1-6. 백엔드 검증 실행


----- Phase 2 백엔드 저장소 그리고 API 레이어 -----

핵심 파일:
  - flow-backend/src/workflow-runtime/infra/in-memory-work-execution-repository.ts
  - flow-backend/src/workflow-runtime/infra/typeorm/ 내 work-execution 관련 파일
  - flow-backend/src/agent/infra/in-memory-agent-log-repository.ts
  - flow-backend/src/agent/infra/typeorm/agent-log.schema.ts
  - flow-backend/src/agent/infra/typeorm/agent-log-typeorm-repository.ts
  - flow-backend/src/agent/application/queries/list-agent-logs-query.ts
  - flow-backend/src/agent/presentation/agent-log.controller.ts
  - flow-backend/src/workflow-runtime/presentation/workflow-runtime.controller.ts
  - flow-backend/src/workflow-runtime/presentation/report.controller.ts
  - flow-backend/src/workflow-runtime/application/queries/get-report-query.ts
참조할 코드 -- 읽기만, 수정하지 않음:
  - flow-backend/src/workflow-runtime/domain/entities/work-execution.ts -- Phase 1에서 수정한 타임스탬프 참조
  - flow-backend/src/workflow-runtime/domain/entities/report.ts -- Report 엔티티의 outline, taskExecutionId 참조

2-1. AgentLogEntry 저장소 스키마 업데이트
     agent-log.schema.ts의 columns에 phase 컬럼 추가 -- varchar 20, nullable.
     in-memory-agent-log-repository.ts는 별도 수정 불필요 -- AgentLogEntry 인터페이스 변경이 자동 반영됨.
     agent-log-typeorm-repository.ts의 toDomain 그리고 toRow 매핑에 phase 필드 추가.

2-2. AgentLogEntry 읽기 모델 업데이트
     list-agent-logs-query.ts의 AgentLogReadModel에 phase 필드 추가 -- string 또는 undefined.
     entries.map 내에서 entry.phase를 포함하여 반환.

2-3. AgentLogController 직렬화 업데이트
     agent-log.controller.ts의 serializeEntry 함수에서 phase 필드를 포함하여 반환.

2-4. WorkExecution 상세 조회 API 신규 생성
     flow-backend/src/workflow-runtime/application/queries/ 디렉토리에
     get-work-execution-detail-query.ts 파일을 새로 생성한다.

     GetWorkExecutionDetailQuery 클래스:
       Injectable 데코레이터 적용.
       constructor에서 WorkExecutionRepository 주입.
       execute 메서드 -- 파라미터로 workExecutionId를 받는다.
       WorkExecutionRepository에서 findById로 WorkExecution을 조회한다.
       없으면 ApplicationError를 throw.
       반환값: id, workflowRunId, sequence, model, currentTaskIndex, isCompleted, isCancelled, startedAt ISO 문자열, completedAt ISO 문자열 또는 null, taskExecutions 배열.
       taskExecutions 배열 각 항목: id, order, query, isCompleted, isFailed, isCancelled, reportId 문자열 또는 null, startedAt ISO 또는 null, completedAt ISO 또는 null.

     WorkflowRuntimeModule의 providers에 GetWorkExecutionDetailQuery를 등록한다.

2-5. WorkflowRuntimeController에 상세 조회 엔드포인트 추가
     workflow-runtime.controller.ts에 다음 엔드포인트를 추가한다:
       GET :id/work-executions/:weId
       constructor에 GetWorkExecutionDetailQuery 주입.
       파라미터: id를 WorkflowRunId로, weId를 WorkExecutionId로 파싱.
       getWorkflowRunQuery 앞에 라우트를 배치 -- NestJS의 라우트 매칭 순서 주의.

2-6. 구조화 리포트 API 신규 생성
     flow-backend/src/workflow-runtime/application/queries/ 디렉토리에
     get-structured-report-query.ts 파일을 새로 생성한다.

     GetStructuredReportQuery 클래스:
       Injectable 데코레이터 적용.
       constructor에서 ReportRepository 그리고 FileSystem 주입.
       execute 메서드 -- 파라미터로 workExecutionId를 받는다.
       ReportRepository에서 findByWorkExecutionId로 모든 Report를 조회.
       없으면 ApplicationError throw.
       각 Report를 다음 구조로 매핑:
         id: report.id 문자열
         taskExecutionId: report.taskExecutionId 문자열
         status: report.status 문자열
         outline: report.outline이 있으면 sections 배열로 변환 -- 각 section의 title, description 포함. 없으면 null.
         content: report.status가 COMPLETED이면 report.content를 반환. content가 없고 filePath가 있으면 fileSystem.readFile로 읽기. 읽기 실패 시 에러 메시지 반환.
         errorMessage: report.errorMessage 또는 null.
       반환: reports 배열.

     WorkflowRuntimeModule의 providers에 등록.

2-7. ReportController에 구조화 리포트 엔드포인트 추가
     report.controller.ts에 다음 엔드포인트를 추가한다:
       GET :workExecutionId/structured
       constructor에 GetStructuredReportQuery 주입.
       기존 getByWorkExecutionId 라우트 앞에 배치 -- :workExecutionId/structured가 먼저 매칭되도록.

2-8. 백엔드 검증 실행


----- Phase 3 백엔드 Task Template 모듈 -----

핵심 파일 -- 전부 신규 생성:
  - flow-backend/src/task-template/ 전체 디렉토리
참조할 코드 -- 읽기만, 수정하지 않음:
  - flow-backend/src/common/value-objects/report-outline.ts -- ReportOutline, Section 재사용
  - flow-backend/src/common/aggregate-root.ts -- AggregateRoot 베이스
  - flow-backend/src/workflow-definition/ -- 기존 모듈 구조 참조

3-1. 도메인 레이어 생성
     flow-backend/src/task-template/domain/ 디렉토리 생성.

     value-objects/task-template-id.ts:
       BrandedId 패턴 따라 TaskTemplateId 생성 -- generate 그리고 create 정적 메서드.

     value-objects/template-category.ts:
       TemplateCategory 타입 정의 -- code_review, bug_analysis, feature_impl, test_writing, documentation, custom.

     entities/task-template.ts:
       TaskTemplate 클래스 -- AggregateRoot 상속하지 않아도 됨, 단순 엔티티로 구현.
       프로퍼티: id -- TaskTemplateId, name -- string, category -- TemplateCategory, description -- string, query -- string, reportOutline -- ReportOutline 또는 null, isBuiltIn -- boolean.
       create 정적 메서드, fromProps 정적 메서드.
       update 메서드 -- name, description, query, reportOutline, category 변경 가능. isBuiltIn이 true이면 RuntimeInvariantViolationError throw.

     ports/task-template-repository.ts:
       TaskTemplateRepository 추상 클래스:
         findAll 추상 메서드 -- 반환 Promise of TaskTemplate 배열
         findById 추상 메서드 -- 반환 Promise of TaskTemplate 또는 null
         save 추상 메서드
         delete 추상 메서드

3-2. 인프라 레이어 생성
     flow-backend/src/task-template/infra/ 디렉토리 생성.

     in-memory-task-template-repository.ts:
       Map 기반 저장소. findAll, findById, save, delete 구현.

     built-in-templates.ts:
       기본 제공 템플릿 5개를 배열로 정의하여 export.
       각 템플릿에 고정 UUID를 사용하여 중복 생성 방지.

       코드 리뷰 템플릿:
         name: 코드 리뷰
         category: code_review
         description: 변경 사항을 분석하고 코드 품질을 평가합니다
         query: 변경된 코드를 리뷰하세요. 코드 품질, 잠재적 버그, 성능 이슈를 분석하세요.
         reportOutline sections: 변경 요약, 코드 품질 분석, 잠재적 이슈, 개선 제안

       버그 분석 템플릿:
         name: 버그 분석
         category: bug_analysis
         description: 버그의 근본 원인을 분석하고 해결 방안을 제시합니다
         query: 보고된 문제에 대한 근본 원인을 분석하세요.
         reportOutline sections: 문제 재현, 근본 원인, 영향 범위, 해결 방안

       기능 구현 템플릿:
         name: 기능 구현
         category: feature_impl
         description: 요구사항에 따라 새 기능을 구현합니다
         query: 요구된 기능을 구현하세요.
         reportOutline sections: 구현 계획, 변경 사항, 테스트 결과, 리뷰 요청 사항

       테스트 작성 템플릿:
         name: 테스트 작성
         category: test_writing
         description: 대상 코드에 대한 테스트를 작성합니다
         query: 대상 코드에 대한 테스트를 작성하세요.
         reportOutline sections: 테스트 전략, 테스트 케이스, 커버리지

       문서 작성 템플릿:
         name: 문서 작성
         category: documentation
         description: 대상에 대한 기술 문서를 작성합니다
         query: 대상에 대한 문서를 작성하세요.
         reportOutline sections: 개요, 사용 방법, API 참조, 예제

3-3. 애플리케이션 레이어 생성
     flow-backend/src/task-template/application/ 디렉토리 생성.

     commands/create-task-template-use-case.ts:
       CreateTaskTemplateUseCase 클래스.
       TaskTemplateRepository 주입.
       execute 메서드: name, category, description, query, reportOutline을 받아 TaskTemplate.create 후 save.

     commands/update-task-template-use-case.ts:
       UpdateTaskTemplateUseCase 클래스.
       findById 후 update 호출 후 save.

     commands/delete-task-template-use-case.ts:
       DeleteTaskTemplateUseCase 클래스.
       findById로 조회, isBuiltIn이면 에러. 아니면 delete.

     queries/list-task-templates-query.ts:
       ListTaskTemplatesQuery 클래스.
       findAll 호출 후 직렬화하여 반환.

3-4. 프레젠테이션 레이어 생성
     flow-backend/src/task-template/presentation/ 디렉토리 생성.

     dto/create-task-template.dto.ts:
       name, category, description, query 필수. reportOutline 옵셔널 -- sections 배열.
       class-validator 데코레이터 적용.

     dto/update-task-template.dto.ts:
       모든 필드 옵셔널.

     task-template.controller.ts:
       Controller 데코레이터 -- 경로 task-templates.
       GET / -- list 반환. POST / -- create. PUT /:id -- update. DELETE /:id -- delete.

3-5. 모듈 등록
     flow-backend/src/task-template/presentation/task-template.module.ts:
       TaskTemplateModule 정의.
       providers: 모든 use case, query, InMemoryTaskTemplateRepository를 TaskTemplateRepository로 제공.
       controllers: TaskTemplateController.
       exports: 필요 시.

     flow-backend/src/app.module.ts에 TaskTemplateModule import 추가.

3-6. 빌트인 템플릿 시드 로직
     TaskTemplateModule의 onModuleInit에서 InMemoryTaskTemplateRepository에 빌트인 템플릿이 없으면 자동 삽입.
     또는 InMemoryTaskTemplateRepository의 constructor에서 빌트인 템플릿을 미리 로드.

3-7. 백엔드 검증 실행


----- Phase 4 프론트엔드 타입 그리고 API 레이어 동기화 -----

핵심 파일:
  - flow-front/src/api/types.ts
  - flow-front/src/api/workflow-runs.ts
  - flow-front/src/lib/query-keys.ts
참조할 코드 -- 읽기만, 수정하지 않음:
  - flow-front/src/components/flow/types.ts -- 노드 데이터 타입 참조

4-1. API 응답 타입 추가 -- types.ts
     AgentLogEntryResponse에 phase 필드 추가 -- string 또는 undefined.

     WorkExecutionDetailResponse 인터페이스 신규 정의:
       id: string
       workflowRunId: string
       sequence: number
       model: string
       currentTaskIndex: number
       isCompleted: boolean
       isCancelled: boolean
       startedAt: string
       completedAt: string 또는 null
       taskExecutions 배열 -- 각 항목:
         id: string
         order: number
         query: string
         isCompleted: boolean
         isFailed: boolean
         isCancelled: boolean
         reportId: string 또는 null
         startedAt: string 또는 null
         completedAt: string 또는 null

     StructuredReportResponse 인터페이스 신규 정의:
       reports 배열 -- 각 항목:
         id: string
         taskExecutionId: string
         status: string
         outline: ReportOutlineData 또는 null -- sections 배열 포함
         content: string 또는 null
         errorMessage: string 또는 null

     ReportOutlineData 인터페이스 신규 정의:
       sections 배열 -- 각 항목: title: string, description: string

     TaskTemplateResponse 인터페이스 신규 정의:
       id: string
       name: string
       category: string
       description: string
       query: string
       reportOutline: ReportOutlineData 또는 null
       isBuiltIn: boolean

     CreateTaskTemplateRequest 인터페이스 신규 정의:
       name, category, description, query 필수. reportOutline 옵셔널.

     UpdateTaskTemplateRequest 인터페이스 신규 정의:
       모든 필드 옵셔널.

4-2. API 클라이언트 함수 추가 -- workflow-runs.ts
     workExecutionsApi 객체 신규 추가:
       getDetail 함수 -- GET /workflow-runs/runId/work-executions/weId --WorkExecutionDetailResponse 반환.

     reportsApi 객체에 추가:
       getStructured 함수 -- GET /reports/workExecutionId/structured --StructuredReportResponse 반환.

     신규 파일 flow-front/src/api/task-templates.ts 생성:
       taskTemplatesApi 객체:
         list 함수 -- GET /task-templates --TaskTemplateResponse 배열 반환.
         create 함수 -- POST /task-templates
         update 함수 -- PUT /task-templates/id
         remove 함수 -- DELETE /task-templates/id

4-3. Query Keys 추가 -- query-keys.ts
     queryKeys 객체에 추가:
       workExecutions 키 -- byId 함수: runId, weId를 받아 키 배열 반환.
       structuredReports 키 -- byWorkExecution 함수: weId를 받아 키 배열 반환.
       taskTemplates 키 -- all, byId.

4-4. 프론트엔드 검증 실행


----- Phase 5 프론트엔드 UI -- Task 상태, 타임라인, 구조화 리포트 -----

핵심 파일:
  - flow-front/src/components/flow/hooks/useWorkflowRunToFlow.ts
  - flow-front/src/components/flow/nodes/TaskNode.tsx
  - flow-front/src/components/flow/panels/WorkExecutionDetailPanel.tsx
  - flow-front/src/components/flow/panels/ReportViewerPanel.tsx
  - flow-front/src/components/flow/types.ts
  - flow-front/src/hooks/useAgentLogs.ts
참조할 코드 -- 읽기만, 수정하지 않음:
  - flow-front/src/components/flow/nodes/WorkNode.tsx -- 노드 렌더링 패턴 참조
  - flow-front/src/components/flow/panels/RunOverviewPanel.tsx -- 패널 레이아웃 참조

5-1. flow/types.ts에 TaskNodeData 확장
     TaskNodeData에 다음 필드 추가:
       taskExecutionId: string 또는 undefined
       startedAt: string 또는 undefined
       completedAt: string 또는 undefined

5-2. useWorkflowRunToFlow에서 Task별 개별 상태 파생
     이 훅에서 WorkExecution 상세 데이터를 추가로 받아야 한다.
     현재 Task 노드에 Work 노드와 동일한 status를 부여하는 로직을 수정한다.

     접근법:
       useWorkflowRunToFlow 훅의 파라미터에 workExecutionDetails 맵을 옵셔널로 추가한다.
       타입: Record of string to WorkExecutionDetailResponse.
       Task 노드 생성 시:
         해당 Work의 workExecutionId로 workExecutionDetails에서 상세를 조회.
         상세가 있으면 taskExecutions 배열에서 해당 order의 TaskExecution을 찾는다.
         TaskExecution의 isCompleted가 true이면 status를 completed로.
         order가 currentTaskIndex와 같고 Work가 running이면 status를 running으로.
         isFailed가 true이면 status를 cancelled로.
         그 외는 pending.
         상세가 없으면 기존 로직대로 Work의 status를 그대로 사용.

     WorkflowRunFlowPage에서 workExecutionDetails를 fetch하여 훅에 전달.
     React Query 훅 생성: useWorkExecutionDetail -- runId, weId, isRunning을 받아 5초 폴링.
     현재 실행 중인 Work의 weId만 조회하면 된다.

5-3. TaskNode 컴포넌트에 개별 상태 시각화
     TaskNode.tsx를 수정한다.
     현재 status에 따른 색상 분기가 이미 있으므로 추가 변경 최소화.
     running 상태일 때 Loader2 아이콘 스피너 표시 -- 현재 이미 구현되어 있을 수 있으므로 확인 후 누락분만 추가.
     failed 상태 추가: 빨간 배경 + X 아이콘.
     completed 상태에 체크 아이콘 추가.

5-4. WorkExecutionDetailPanel 탭 확장
     현재 2개 탭을 3개로 확장한다:
       에이전트 로그 탭 -- 기존
       리포트 탭 -- StructuredReportViewer로 교체
       타임라인 탭 -- 신규

     탭 상단에 Task 스텝 인디케이터 추가:
       Task 1, 2, 3 ... 을 수평으로 나열.
       각 Task 사이에 화살표.
       현재 실행 중인 Task 강조.
       이 인디케이터는 workExecutionDetail 데이터에서 파생.

5-5. StructuredReportViewer 신규 컴포넌트 생성
     flow-front/src/components/flow/panels/StructuredReportViewer.tsx 파일 생성.

     Props: workExecutionId -- string, isRunning -- boolean.
     React Query로 reportsApi.getStructured 호출, isRunning이면 5초 폴링.

     레이아웃:
       각 report를 아코디언 형태로 표시.
       아코디언 헤더: Task 순서 + 상태 뱃지 -- PENDING이면 스피너, COMPLETED이면 체크, FAILED이면 에러 아이콘.
       아코디언 본문:
         outline이 있으면 sections를 순회하며 각 section의 title을 소제목으로, content를 ## 헤더 기준으로 파싱하여 해당 섹션 내용 렌더링.
         outline이 없으면 content 전체를 ReactMarkdown으로 렌더링.
       content가 null이고 status가 PENDING이면 리포트 생성 대기 중... 이라는 텍스트를 표시.
       errorMessage가 있으면 빨간 배경으로 에러 메시지 표시.

     content 파싱 로직:
       content 문자열을 ## 헤더 기준으로 split.
       outline sections의 title과 매칭하여 각 섹션의 내용을 추출.
       매칭되지 않는 나머지 내용은 기타 섹션으로 표시.

5-6. ExecutionTimeline 신규 컴포넌트 생성
     flow-front/src/components/flow/panels/ExecutionTimeline.tsx 파일 생성.

     Props: runDetail -- WorkflowRunDetailResponse, workExecutionDetails -- WorkExecutionDetailResponse 배열.

     레이아웃:
       세로 타임라인. 각 Work를 큰 항목으로, 그 안의 Task를 하위 항목으로 표시.
       각 항목에 시작시간, 종료시간, 소요시간 표시.
       진행 중인 항목에는 경과 시간을 실시간 업데이트 -- useEffect + setInterval.
       완료된 항목은 소요시간 표시.
       시간 포맷: HH:MM 형식 + 소요시간은 N분 N초 형식.
       상태 아이콘: 완료=체크, 실행중=스피너, 대기=시계.

5-7. 프론트엔드 검증 실행


----- Phase 6 프론트엔드 UI -- 에이전트 Phase 표시 그리고 템플릿 시스템 -----

핵심 파일:
  - flow-front/src/components/flow/panels/AgentLogPanel.tsx
  - flow-front/src/components/flow/panels/RuntimeWorkNodePanel.tsx
  - flow-front/src/pages/workflow/WorkflowFlowEditorPage.tsx
참조할 코드 -- 읽기만, 수정하지 않음:
  - flow-front/src/api/types.ts -- Phase 4에서 추가한 타입들
  - flow-front/src/api/task-templates.ts -- Phase 4에서 생성한 API 클라이언트

6-1. AgentLogPanel에 Phase 기반 그룹화 추가
     AgentLogPanel.tsx를 수정한다.

     상단에 AgentPhaseTimeline 컴포넌트 추가:
       수평 바 형태로 thinking --executing --reporting 단계를 표시.
       현재 단계를 강조 -- 로그 엔트리의 마지막 phase 기준.
       각 단계 아이콘: thinking은 구름, executing은 기어, reporting은 문서.

     기존 로그 목록을 phase별로 그룹화:
       연속된 같은 phase의 엔트리들을 하나의 섹션으로 묶는다.
       각 섹션 헤더에 phase 이름과 아이콘 표시.
       thinking 섹션: assistant_text 내용을 펼쳐서 표시 -- 에이전트의 사고 과정 강조.
       executing 섹션: 기존 tool group 로직 유지 -- 도구 사용 요약.
       reporting 섹션: assistant_text 내용 표시.
       phase가 없는 엔트리는 기존 방식으로 표시 -- 하위호환.

     AgentPhaseTimeline을 별도 컴포넌트로 분리할 수도 있으나, AgentLogPanel 내에 인라인으로 구현해도 무방.

6-2. 템플릿 선택 다이얼로그 생성
     flow-front/src/components/flow/panels/TemplatePickerDialog.tsx 파일 생성.

     Props:
       open -- boolean
       onClose -- 콜백
       onSelect -- 콜백, 선택된 템플릿의 query와 reportOutline을 전달

     React Query로 taskTemplatesApi.list 호출.

     레이아웃:
       Dialog 컴포넌트 사용 -- shadcn/ui Dialog.
       제목: 템플릿 선택.
       카테고리별 그룹화:
         기본 템플릿 -- isBuiltIn이 true
         내 템플릿 -- isBuiltIn이 false
       각 템플릿 카드:
         이름, 카테고리 뱃지, 설명.
         클릭 시 미리보기 표시 -- query 내용과 reportOutline sections.
         선택 버튼.
       선택 시 onSelect에 query와 reportOutline 전달 후 onClose.

6-3. RuntimeWorkNodePanel에 템플릿 선택 기능 추가
     RuntimeWorkNodePanel.tsx를 수정한다.

     Tasks 섹션 헤더 옆에 템플릿에서 추가 버튼 추가.
     버튼 클릭 시 TemplatePickerDialog 열기.
     템플릿 선택 시:
       taskConfigs useFieldArray에 새 항목 추가.
       query를 템플릿의 query로 설정.
       hasReportOutline을 템플릿의 reportOutline 유무로 설정.
       reportOutline 데이터를 숨겨진 필드로 전달하거나, 별도 state로 관리.

     handleSubmit에서 각 task의 reportOutline을 서버에 전달해야 하므로:
       EditWorkNodeConfigRequest 그리고 AddWorkNodeRequest의 taskConfigs에 reportOutline 필드를 추가해야 할 수 있다.
       이 경우 Phase 2의 DTO 그리고 Phase 4의 타입도 함께 수정한다.
       또는 reportOutline은 별도 API로 관리하는 방안도 고려.
       가장 간단한 접근: taskConfigs 내에 reportOutline을 포함시킨다.

6-4. 워크플로우 편집기에서도 템플릿 사용 가능하게
     WorkflowFlowEditorPage의 WorkNodePanel -- 워크플로우 정의 편집 패널 -- 에서도
     동일한 TemplatePickerDialog를 사용하여 Task 추가 시 템플릿 선택 가능하게 한다.
     RuntimeWorkNodePanel과 동일한 패턴 적용.

6-5. 프론트엔드 검증 실행


----- Phase 7 통합 검증 -----

7-1. 백엔드 서버 실행
     cd flow-backend && npm run build && npm run start
     서버가 정상 기동되는지 확인한다. 포트 3000에서 응답하는지 확인.

7-2. 프론트엔드 dev 서버 실행
     cd flow-front && npm run dev
     정상 기동 확인. 포트 5173에서 접근 가능한지 확인.

7-3. Playwright MCP로 다음 시나리오를 검증:

     시나리오 A -- Task별 실행 상태 표시:
       localhost:5173에서 워크플로우를 실행한다.
       런타임 상세 페이지에서 Work 노드 클릭.
       해당 Work 내의 Task 노드들이 각각 다른 상태 색상을 보이는지 확인.
       완료된 Task는 파란색, 실행 중인 Task는 초록색 스피너, 대기 Task는 회색.

     시나리오 B -- 구조화 리포트 뷰어:
       실행 완료된 워크플로우의 Work 노드 클릭.
       리포트 탭 선택.
       Task별로 아코디언이 분리되어 표시되는지 확인.
       reportOutline이 있는 Task의 리포트가 섹션별로 구분되는지 확인.

     시나리오 C -- 실행 타임라인:
       실행 완료된 워크플로우에서 타임라인 탭 선택.
       각 Work와 Task의 시작/종료 시간이 표시되는지 확인.
       소요 시간이 계산되어 표시되는지 확인.

     시나리오 D -- 에이전트 사고 과정 Phase:
       실행 중 또는 완료된 워크플로우의 에이전트 로그 탭 확인.
       상단에 thinking --executing --reporting Phase 바가 표시되는지 확인.
       로그가 phase별로 그룹화되어 표시되는지 확인.

     시나리오 E -- 템플릿 시스템:
       런타임 상세에서 PAUSED 상태일 때 Work 노드 편집 패널 열기.
       템플릿에서 추가 버튼 클릭.
       템플릿 선택 다이얼로그가 열리는지 확인.
       기본 제공 템플릿 5개가 표시되는지 확인.
       템플릿 선택 후 query와 reportOutline이 자동 채워지는지 확인.

     시나리오 F -- 워크플로우 편집기 템플릿:
       워크플로우 편집 페이지에서 Work 노드의 Task 추가 시 템플릿 선택 가능한지 확인.

7-4. 문제 발견 시 즉시 수정하고 재검증

7-5. 최종 검증 실행:
     cd flow-backend && npm run typecheck && npm run test && npm run lint
     cd flow-front && npx tsc -b && npm run lint && npm run build

모든 Phase가 완료되고 전체 시나리오 검증이 통과하면 EXECUTION UX IMPROVEMENT COMPLETE 를 출력한다.
