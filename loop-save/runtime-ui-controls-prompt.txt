워크플로우 런타임 UI의 6가지 갭을 수정한다.
백엔드 API(pause, resume, cancel, delete, start, reports)는 이미 완성되어 있으므로 백엔드는 수정하지 않는다.
수정 범위는 프론트엔드(hooks, panels, nodes, pages)이다.
flow-front/CLAUDE.md의 모든 규칙을 준수한다.

수정할 갭 목록:
  갭1. 런타임 상세 페이지에 실행/재실행 버튼이 없음 — COMPLETED/CANCELLED 상태에서 아무 액션 불가
  갭2. 폴링이 RUNNING 상태에서만 동작하여 상태 전환이 실시간 반영되지 않음
  갭3. 실행중 노드의 시각적 피드백이 부족함 — 실행중 Work/Task 노드에 명확한 인디케이터 필요
  갭4. 실행중 생성되는 리포트가 보이지 않음 — 현재 진행중인 Work의 완료된 Task 리포트 접근 불가
  갭5. COMPLETED/CANCELLED 상태에서 삭제 버튼이 없고, PAUSED/AWAITING에서 체크포인트 복원이 RunOverviewPanel에 직접 노출되지 않음
  갭6. 워크노드 간 일시정지(pauseAfter)가 설정되면 항상 수동 재개 필요 — 런타임에서 "자동 진행" 모드를 제공하여 pauseAfter 일시정지를 선택적으로 건너뛸 수 있어야 함

아래 4개 Phase를 순서대로 진행한다.
각 Phase 완료 후 반드시 아래 검증을 실행한다. 검증 실패 시 수정 후 다시 검증한다. 검증 통과 후 다음 Phase로 진행한다.
  프론트엔드 검증: cd flow-front && npx tsc -b && npm run lint && npm run build
각 Phase 완료 후 Playwright MCP를 통해 localhost:5173에 접속하여 실제 화면을 확인하고 문제가 있으면 즉시 수정한다.

----- Phase 1 폴링 전략 수정 — 실시간 상태 반영 -----

핵심 파일:
  - flow-front/src/hooks/useWorkflowRuns.ts
참조할 코드 (읽기만, 수정하지 않음):
  - flow-front/src/api/workflow-runs.ts (API 함수 목록)
  - flow-front/src/api/types.ts (WorkflowRunStatus 타입: INITIALIZED | RUNNING | PAUSED | AWAITING | COMPLETED | CANCELLED)

1-1. useWorkflowRunDetail의 detailQuery refetchInterval 수정 (갭2 해결)
     현재 코드:
       refetchInterval: (query) =>
         query.state.data?.status === 'RUNNING' ? 3000 : false,
     변경:
       refetchInterval: (query) => {
         const status = query.state.data?.status;
         if (!status) return 3000;
         if (status === 'COMPLETED' || status === 'CANCELLED') return false;
         if (status === 'RUNNING') return 2000;
         return 5000;
       },
     의미: 터미널 상태(COMPLETED, CANCELLED)가 아닌 모든 상태에서 폴링한다.
     RUNNING은 2초, INITIALIZED/PAUSED/AWAITING은 5초 간격으로 폴링한다.
     이렇게 하면 INITIALIZED → RUNNING, RUNNING → AWAITING 등 비동기 전환도 즉시 반영된다.

1-2. mutation 후 추가 갱신 보장
     pauseMutation, resumeMutation, cancelMutation의 onSuccess에 딜레이 refetch 추가:
       onSuccess: () => {
         queryClient.invalidateQueries({ queryKey: queryKeys.workflowRuns.detail(id) });
         setTimeout(() => {
           void queryClient.refetchQueries({ queryKey: queryKeys.workflowRuns.detail(id) });
         }, 800);
       },
     이유: 백엔드의 비동기 이벤트 핸들러(에이전트 세션 정리, 다음 작업 시작 등)가 완료된 후의
     상태를 정확히 반영하기 위함. invalidation만으로는 즉시 반환된 상태만 가져올 수 있다.

1-3. checkpointsQuery의 enabled 조건 확장
     현재 코드:
       enabled: detailQuery.data?.status === 'PAUSED' || detailQuery.data?.status === 'AWAITING',
     변경:
       enabled: detailQuery.data?.status === 'PAUSED'
         || detailQuery.data?.status === 'AWAITING'
         || detailQuery.data?.status === 'COMPLETED'
         || detailQuery.data?.status === 'CANCELLED',
     이유: COMPLETED/CANCELLED 상태에서도 체크포인트 목록을 볼 수 있도록 한다.
     (Phase 2에서 RunOverviewPanel에 체크포인트 복원 UI를 추가할 때 필요)

1-4. 프론트엔드 검증 실행

----- Phase 2 런타임 컨트롤 UI 완성 -----

핵심 파일:
  - flow-front/src/components/flow/panels/RunOverviewPanel.tsx
  - flow-front/src/pages/WorkflowRunFlowPage.tsx
  - flow-front/src/hooks/useWorkflowRuns.ts
참조할 코드 (읽기만, 수정하지 않음):
  - flow-front/src/api/workflow-runs.ts (workflowRunsApi.start, workflowRunsApi.delete)
  - flow-front/src/api/types.ts (StartWorkflowRunRequest)

2-1. RunOverviewPanel props 확장
     기존 props에 다음 추가:
       onDelete: () => void;
       onRerun: () => void;
       isDeletePending: boolean;
       isRerunPending: boolean;
       checkpoints?: CheckpointResponse[];
       onRestore?: (checkpointId: string) => void;
       isRestorePending?: boolean;
     import에 CheckpointResponse 타입 추가 (from '@/api/types').
     import에 RotateCcw, Trash2, History 아이콘 추가 (from 'lucide-react').

2-2. RunOverviewPanel에 COMPLETED 상태 UI 추가 (갭1, 갭5 해결)
     status === 'COMPLETED' 조건 블록 추가:
       - "재실행" 버튼: <RotateCcw /> 아이콘, onClick={onRerun}, disabled={isRerunPending}
       - "삭제" 버튼: <Trash2 /> 아이콘, variant="destructive", onClick={onDelete}, disabled={isDeletePending}

2-3. RunOverviewPanel에 CANCELLED 상태 UI 추가 (갭1, 갭5 해결)
     status === 'CANCELLED' 조건 블록 추가:
       - "재실행" 버튼: 2-2와 동일
       - "삭제" 버튼: 2-2와 동일
     취소 사유(runDetail.cancellationReason) 표시는 이미 구현되어 있으므로 유지.

2-4. RunOverviewPanel에 INITIALIZED 상태 UI 추가
     status === 'INITIALIZED' 조건 블록 추가:
       - <div className="flex items-center gap-2 text-sm text-muted-foreground">
           <Loader2 className="h-4 w-4 animate-spin" />
           실행 준비 중...
         </div>
     import에 Loader2 추가 (from 'lucide-react').

2-5. RunOverviewPanel에 체크포인트 복원 섹션 추가 (갭5 해결)
     PAUSED 또는 AWAITING 상태에서 checkpoints 배열이 존재하고 비어있지 않을 때:
       <div className="border-t pt-3 mt-3">
         <p className="text-sm font-medium mb-2 flex items-center gap-1">
           <History className="h-4 w-4" /> 체크포인트 복원
         </p>
         {checkpoints.map(cp => (
           <div key={cp.id} className="flex items-center justify-between py-1 text-sm">
             <span>Work #{cp.workSequence + 1}</span>
             <Button
               variant="ghost" size="sm"
               onClick={() => onRestore?.(cp.id)}
               disabled={isRestorePending}
             >
               복원
             </Button>
           </div>
         ))}
       </div>

2-6. useWorkflowRunDetail에 startNewRun mutation 추가
     useWorkflowRunDetail 훅에서 workflowRunsApi를 import.
     startNewRunMutation 추가:
       const startNewRunMutation = useMutation({
         mutationFn: (workflowId: string) => workflowRunsApi.start({ workflowId }),
         onSuccess: () => {
           queryClient.invalidateQueries({ queryKey: queryKeys.workflowRuns.all });
         },
       });
     return 객체에 startNewRunMutation 추가.

2-7. WorkflowRunFlowPage에서 RunOverviewPanel에 새 props 전달
     RunOverviewPanel에 다음 props 추가 전달:
       onDelete={() => deleteMutation.mutate(undefined, {
         onSuccess: () => navigate('/'),
       })}
       onRerun={() => startNewRunMutation.mutate(runDetail.workflowId, {
         onSuccess: (data) => navigate(`/workflow-runs/${data.workflowRunId}`),
       })}
       isDeletePending={deleteMutation.isPending}
       isRerunPending={startNewRunMutation.isPending}
       checkpoints={checkpoints}
       onRestore={(checkpointId) => resumeMutation.mutate(checkpointId, {
         onSuccess: () => setSelectedPanel({ type: 'overview' }),
       })}
       isRestorePending={resumeMutation.isPending}
     useWorkflowRunDetail 반환값에서 startNewRunMutation 추가 디스트럭처링.
     useNavigate import 확인.

2-8. WorkflowRunFlowPage 헤더에 상태별 버튼 추가 (갭1 해결)
     현재 헤더에는 PAUSED/AWAITING일 때만 "작업 추가", "체크포인트" 버튼이 있다.
     추가할 버튼:
       {(runDetail.status === 'COMPLETED' || runDetail.status === 'CANCELLED') && (
         <Button
           variant="outline"
           size="sm"
           onClick={() => startNewRunMutation.mutate(runDetail.workflowId, {
             onSuccess: (data) => navigate(`/workflow-runs/${data.workflowRunId}`),
           })}
           disabled={startNewRunMutation.isPending}
         >
           <RotateCcw className="mr-1 h-4 w-4" />
           재실행
         </Button>
       )}
     import에 RotateCcw 추가.

2-9. RunOverviewPanel props에 자동 진행 관련 추가 (갭6 해결)
     기존 props에 다음 추가:
       autoResume: boolean;
       onAutoResumeChange: (value: boolean) => void;
     import에 FastForward 아이콘 추가 (from 'lucide-react').

2-10. RunOverviewPanel에 "자동 진행" 토글 추가 (갭6 해결)
      RUNNING 또는 AWAITING 상태에서 표시:
        <div className="flex items-center gap-2 border-t pt-3 mt-3">
          <Checkbox
            id="auto-resume"
            checked={autoResume}
            onCheckedChange={(checked) => onAutoResumeChange(checked === true)}
          />
          <label htmlFor="auto-resume" className="text-sm font-medium flex items-center gap-1">
            <FastForward className="h-4 w-4" />
            자동 진행
          </label>
        </div>
        {autoResume && (
          <p className="text-xs text-muted-foreground mt-1">
            워크 완료 후 일시정지 없이 다음 워크로 자동 진행합니다
          </p>
        )}
      import에 Checkbox 추가 (from '@/components/ui/checkbox').
      의미: pauseAfter가 설정된 워크노드 전환 시에도 자동으로 재개하여
      수동 재개 없이 워크플로우가 끝까지 실행되도록 한다.
      토글이 꺼져 있으면 기존 동작(AWAITING에서 수동 재개 필요)을 유지한다.

2-11. WorkflowRunFlowPage에 autoResume 상태 및 자동 재개 로직 추가 (갭6 해결)
      상태 추가:
        const [autoResume, setAutoResume] = useState(false);
      useEffect로 AWAITING 상태 감지 시 자동 재개:
        useEffect(() => {
          if (autoResume && runDetail?.status === 'AWAITING') {
            resumeMutation.mutate(undefined);
          }
        }, [autoResume, runDetail?.status]);
      주의: resumeMutation은 기존 디스트럭처링에서 이미 사용 가능.
      의미: autoResume이 활성화되고 상태가 AWAITING으로 바뀌면 즉시 resume API를 호출한다.
      폴링(Phase 1에서 수정)이 AWAITING 상태를 감지하면 이 effect가 트리거된다.
      PAUSED 상태(사용자 수동 일시정지)에서는 자동 재개하지 않는다.

      RunOverviewPanel에 props 전달:
        autoResume={autoResume}
        onAutoResumeChange={setAutoResume}

2-12. 프론트엔드 검증 실행

----- Phase 3 실행 노드 시각화 강화 + 리포트 접근성 -----

핵심 파일:
  - flow-front/src/components/flow/nodes/WorkNode.tsx
  - flow-front/src/components/flow/nodes/TaskNode.tsx
  - flow-front/src/pages/WorkflowRunFlowPage.tsx
  - flow-front/src/components/flow/panels/ReportViewerPanel.tsx
참조할 코드 (읽기만, 수정하지 않음):
  - flow-front/src/components/flow/constants.ts (NODE_STATUS_COLORS)
  - flow-front/src/components/flow/types.ts (NodeStatus, mapRunStatus)
  - flow-front/src/index.css (flow-node-running 애니메이션)
  - flow-backend/src/workflow-runtime/presentation/report.controller.ts
    (GET /reports/:workExecutionId — 리포트가 없으면 404, 완료된 리포트가 없으면 { content: '' } 반환)

3-1. WorkNode에 실행 상태 인디케이터 추가 (갭3 해결)
     WorkNode.tsx에서 data.status === 'running'일 때 추가 UI:
       import { Loader2 } from 'lucide-react'
       Work #{data.workIndex + 1} 레이블 옆에:
         {data.status === 'running' && (
           <span className="flex items-center gap-1 text-xs text-green-600 font-medium">
             <Loader2 className="h-3 w-3 animate-spin" />
             실행 중
           </span>
         )}
     이 인디케이터는 기존 pulse 애니메이션(flow-node-running)과 함께 동작한다.

3-2. TaskNode에 실행 상태 시각적 피드백 추가 (갭3 해결)
     TaskNode.tsx에서 status === 'running'일 때 flow-node-running 클래스 추가:
       className에 data.status === 'running' && 'flow-node-running' 추가
     Task 레이블에 실행 상태 표시:
       {data.status === 'running' && (
         <span className="text-xs text-green-600">실행 중</span>
       )}
       {data.status === 'completed' && (
         <span className="text-xs text-blue-600">완료</span>
       )}

3-3. WorkflowRunFlowPage onNodeSelect 수정: 실행중 Work 리포트 접근 (갭4 해결)
     현재 코드 (line 67):
       if (seq < runDetail.currentWorkIndex && runDetail.workExecutionIds?.[seq]) {
         setSelectedPanel({ type: 'report', workExecutionId: runDetail.workExecutionIds[seq] });
       }
     변경:
       if (runDetail.workExecutionIds?.[seq]) {
         setSelectedPanel({ type: 'report', workExecutionId: runDetail.workExecutionIds[seq] });
       }
     이렇게 하면 현재 실행중인 Work 노드를 클릭해도 리포트 패널이 열린다.
     (리포트가 아직 없으면 ReportViewerPanel이 적절한 메시지를 표시 — 3-4에서 처리)

     Task 노드에 대해서도 동일 수정 (line 78):
       if (seq < runDetail.currentWorkIndex && runDetail.workExecutionIds?.[seq]) {
     변경:
       if (runDetail.workExecutionIds?.[seq]) {

3-4. ReportViewerPanel 개선 (갭4 해결)
     ReportViewerPanel.tsx를 다음과 같이 수정:

     a) isRunning prop 추가:
        interface ReportViewerPanelProps {
          workExecutionId: string;
          isRunning?: boolean;
        }

     b) reportQuery에 refetchInterval 추가:
        const reportQuery = useQuery({
          queryKey: ['reports', workExecutionId],
          queryFn: () => reportsApi.get(workExecutionId),
          enabled: !!workExecutionId,
          refetchInterval: isRunning ? 5000 : false,
          retry: (failureCount, error) => {
            if ((error as { status?: number })?.status === 404) return false;
            return failureCount < 3;
          },
        });
        의미: 실행중인 Work의 리포트는 5초마다 폴링하여 새 리포트가 생성되면 자동 표시.
        404 에러(리포트 미존재)는 재시도하지 않음.

     c) 에러/빈 상태 UI 개선:
        reportQuery.isError && (error as { status?: number })?.status === 404:
          <p>아직 생성된 리포트가 없습니다.</p>
          {isRunning && (
            <p className="text-xs text-muted-foreground mt-1">실행 중 — 리포트가 생성되면 자동으로 표시됩니다.</p>
          )}
        reportQuery.data?.content이 빈 문자열:
          <p>리포트 생성 중...</p>
          {isRunning && (
            <div className="flex items-center gap-1 text-xs text-muted-foreground mt-1">
              <Loader2 className="h-3 w-3 animate-spin" /> 작업 완료 시 자동 갱신
            </div>
          )}
        import에 Loader2 추가.

3-5. WorkflowRunFlowPage에서 ReportViewerPanel에 isRunning prop 전달
     selectedPanel.type === 'report' 렌더링에서:
       <ReportViewerPanel
         workExecutionId={selectedPanel.workExecutionId}
         isRunning={runDetail.status === 'RUNNING'}
       />

3-6. 프론트엔드 검증 실행

----- Phase 4 통합 검증 -----

4-1. 백엔드 서버 실행 상태 확인 (cd flow-backend && npm run start:dev)
4-2. 프론트엔드 dev 서버 실행 상태 확인 (cd flow-front && npm run dev)
4-3. Playwright MCP로 다음 시나리오를 검증:
     시나리오 A — 폴링 동작 확인:
       localhost:5173에서 워크플로우 목록 페이지(/workflows)로 이동
       ACTIVE 워크플로우의 드롭다운에서 "실행" 클릭
       런타임 상세 페이지(/workflow-runs/:id)로 자동 이동 확인
       상태 뱃지가 RUNNING으로 표시되는지 확인
       RunOverviewPanel에 "일시정지", "취소", "에이전트 세션" 버튼이 표시되는지 확인
     시나리오 B — 실행중 노드 시각화:
       RUNNING 상태의 런타임 상세 페이지에서:
       현재 실행중인 Work 노드에 초록색 테두리 + pulse 애니메이션 + "실행 중" 텍스트 확인
       해당 Work의 Task 노드에도 실행 상태 표시 확인
     시나리오 C — 런타임 컨트롤:
       RUNNING 상태에서 "일시정지" 클릭 → 상태가 PAUSED로 전환되는지 확인
       PAUSED 상태에서 "재개", "취소" 버튼 표시 확인
       체크포인트가 있으면 RunOverviewPanel에 "체크포인트 복원" 섹션 표시 확인
       "재개" 클릭 → RUNNING으로 복귀 확인
     시나리오 D — 터미널 상태 UI:
       워크플로우가 COMPLETED 또는 CANCELLED 상태일 때:
       RunOverviewPanel에 "재실행", "삭제" 버튼 표시 확인
       헤더에 "재실행" 버튼 표시 확인
       "재실행" 클릭 → 새 런 생성 및 해당 페이지로 이동 확인
     시나리오 E — 리포트 접근:
       RUNNING 상태에서 현재 실행중인 Work 노드 클릭
       리포트 패널이 열리는지 확인 (리포트가 없으면 "아직 생성된 리포트가 없습니다" 메시지)
       완료된 Work 노드 클릭 시 리포트가 정상 표시되는지 확인
     시나리오 F — 자동 진행 모드:
       RUNNING 상태에서 RunOverviewPanel에 "자동 진행" 체크박스가 표시되는지 확인
       체크박스 활성화 후 워크 완료 시 AWAITING → 자동 RUNNING 전환 확인 (수동 재개 불필요)
       체크박스 비활성화 시 AWAITING 상태에서 멈추고 수동 재개 필요 확인
       PAUSED 상태(수동 일시정지)에서는 자동 진행이 동작하지 않는지 확인
4-4. 문제 발견 시 즉시 수정하고 재검증
4-5. 최종 검증 실행:
     cd flow-front && npx tsc -b && npm run lint && npm run build

모든 Phase가 완료되고 전체 시나리오 검증이 통과하면 RUNTIME UI CONTROLS FIX COMPLETE 를 출력한다.
