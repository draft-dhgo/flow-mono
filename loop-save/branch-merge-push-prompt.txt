작업 리니지 기반 브랜치 통합(에이전트 위임)과 완료된 작업의 선택적 원격 푸시 기능을 추가한다.
flow-front/CLAUDE.md와 flow-backend/CLAUDE.md의 모든 규칙을 준수한다.

선행 조건:
  git-safety-prompt.txt -- GitClient/GitService에 push, merge 메서드 추가 완료
  work-lineage-prompt.txt -- 작업 리니지 조회 + 내보내기 완료
  adhoc-workspace-prompt.txt -- 워크스페이스 모듈 + 채팅 기능 완료

브랜치 통합이란:
  사용자가 리니지 테이블에서 통합할 워크플로우 런을 선택하면,
  각 프로젝트(git 레포)별로 머지해야 할 브랜치를 집계하고,
  애드혹 워크스페이스의 에이전트에게 머지 작업을 위임한다.
  에이전트는 채팅 컨텍스트에서 git merge를 수행한다.

선택적 원격 푸시란:
  완료된 워크플로우 런 또는 워크스페이스의 로컬 브랜치를 사용자가 선택하여 원격으로 푸시한다.
  이때 git-safety-prompt에서 추가한 GitService.push 메서드를 사용한다.
  pre-push hook이 설치되어 있으므로, 먼저 hook을 임시 해제하고 push 후 재설치한다.

수정할 항목 목록:
  A1. PushBranchesUseCase 생성 (워크플로우 런용)
  A2. PushWorkspaceBranchesUseCase 생성 (워크스페이스용)
  A3. 런타임 컨트롤러에 push 엔드포인트 추가
  A4. 워크스페이스 컨트롤러에 push 엔드포인트 추가
  B1. MergeBranchesUseCase 생성
  B2. 워크스페이스 컨트롤러에 merge 엔드포인트 추가
  C1. 프론트엔드 워크플로우 런 푸시 UI
  C2. 프론트엔드 워크스페이스 푸시 UI
  D1. 프론트엔드 리니지 통합 UI

아래 5개 Phase를 순서대로 진행한다.
각 Phase 완료 후 반드시 아래 검증을 실행한다. 검증 실패 시 수정 후 다시 검증한다.
  백엔드 검증: cd flow-backend && npm run typecheck && npm run test && npm run lint
  프론트엔드 검증: cd flow-front && npx tsc -b && npm run lint && npm run build
각 Phase 완료 후 Playwright MCP를 통해 localhost:5173에 접속하여 실제 화면을 확인하고 문제가 있으면 즉시 수정한다.


----- Phase 1 백엔드 -- PushBranchesUseCase + 엔드포인트 -- A1~A4 -----

핵심 파일:
  - flow-backend/src/workflow-runtime/application/commands/push-branches-use-case.ts -- 신규
  - flow-backend/src/workspace/application/commands/push-workspace-branches-use-case.ts -- 신규
  - flow-backend/src/workflow-runtime/presentation/workflow-runtime.controller.ts -- 수정
  - flow-backend/src/workspace/presentation/workspace.controller.ts -- 수정
  - flow-backend/src/workflow-runtime/presentation/workflow-runtime.module.ts -- 수정
  - flow-backend/src/workspace/presentation/workspace.module.ts -- 수정
참조할 코드 -- 읽기만, 수정하지 않음:
  - flow-backend/src/git/domain/ports/git-client.ts -- push, installPrePushHook
  - flow-backend/src/common/ports/git-service.ts -- push, installPrePushHook
  - flow-backend/src/workflow-runtime/domain/entities/work-tree.ts -- WorkTree
  - flow-backend/src/workflow-runtime/domain/ports/work-tree-repository.ts

1-1. 푸시 결과 인터페이스 정의

     공통 파일 또는 각 UseCase 파일 상단에 정의:

     export interface PushResult:
       gitId -- string
       branch -- string
       success -- boolean
       error -- string 또는 null

     export interface PushBranchesResult:
       results -- PushResult 배열

1-2. PushBranchesUseCase 생성 (워크플로우 런용)

     파일: flow-backend/src/workflow-runtime/application/commands/push-branches-use-case.ts

     @Injectable 데코레이터
     생성자 주입:
       - WorkflowRunRepository
       - WorkTreeRepository
       - GitService
       - GitReader

     async execute(workflowRunId: WorkflowRunId): Promise<PushBranchesResult>

     execute 로직:
       1. run = await workflowRunRepository.findById(workflowRunId)
          없으면 에러

       2. COMPLETED 상태 확인:
          if run.status !== WorkflowRunStatus.COMPLETED then
            throw ApplicationError: '완료된 워크플로우 런만 푸시할 수 있습니다.'

       3. WorkTree 목록 조회:
          const workTrees = await workTreeRepository.findByWorkflowRunId(workflowRunId)
          if workTrees.length === 0 then return { results: [] }

       4. git 정보 조회:
          const gitInfos = await gitReader.findByIds(workTrees.map(wt => wt.gitId))

       5. 각 worktree에 대해 push 수행:
          const results: PushResult[] = []
          for each wt of workTrees:
            const gitInfo = gitInfos.find(g => g.id === wt.gitId)
            if not gitInfo then
              results.push({ gitId: wt.gitId, branch: wt.branch, success: false, error: 'Git 레포 정보를 찾을 수 없습니다.' })
              continue

            try:
              -- 현재 브랜치명 확인
              const currentBranch = await this.gitService.getCurrentBranch(wt.path)

              -- pre-push hook 임시 제거 (GitService에 없으면 직접 파일 삭제)
              -- 방법 1: GitClient에 removePrePushHook 메서드 추가
              -- 방법 2: 파일 시스템으로 직접 제거
              -- 권장: GitService에 removePrePushHook + installPrePushHook 사이클 사용
              -- 하지만 GitClient에 push 메서드가 있으므로 hook과 무관하게 push 가능:
              -- GitClient.push는 exec('git', ['push', ...])를 직접 호출하므로
              -- hook이 설치되어 있어도 프로그래밍적 push는 hook을 트리거함.
              -- 해결: GitClient.push에서 --no-verify 옵션을 사용하거나,
              -- push 전에 hook 파일을 임시로 이름 변경하고 push 후 복원.

              -- 최선의 방법: CliGitClient.push에서 환경변수로 hook 우회:
              -- GIT_PUSH_OPTIONS 또는 hook 파일 임시 제거/복원.
              -- 가장 안전한 방법: push 메서드에서 hook 파일을 임시 이름 변경.

              -- 실제 구현에서는 CliGitClient.push 메서드를 수정하여:
              --   1. worktree의 hook 파일을 임시 이름(.pre-push.bak)으로 변경
              --   2. git push 실행
              --   3. hook 파일 복원
              -- 또는: exec에 GIT_CONFIG_NOSYSTEM=1 등 환경변수 설정

              -- 간단한 접근: GitClient에 pushWithForce 또는 pushBypassHook 메서드 추가.
              -- CliGitClient에서 구현:
              --   const hookPath = ... pre-push hook 경로 계산
              --   const backupPath = hookPath + '.bak'
              --   try: await rename(hookPath, backupPath) catch: 무시
              --   await this.exec(repoPath, ['push', 'origin', branch])
              --   try: await rename(backupPath, hookPath) catch: 무시

              -- 여기서는 GitService 레벨에서 처리:
              await this.gitService.push(wt.path, currentBranch)
              -- push 메서드가 이미 hook을 우회하도록 구현되어야 함.
              -- 만약 아직 우회 로직이 없다면, CliGitClient.push를 수정하여
              -- push 전후로 hook 파일 백업/복원 로직을 추가한다.

              results.push({ gitId: wt.gitId, branch: currentBranch, success: true, error: null })
            catch err:
              results.push({
                gitId: wt.gitId,
                branch: wt.branch,
                success: false,
                error: err instanceof Error ? err.message : String(err),
              })

          return { results }

     주의: CliGitClient.push 메서드에 pre-push hook 우회 로직 추가가 필요할 수 있다.
       기존 push 메서드를 수정:
         async push(repoPath: string, branch: string): Promise<void>
           -- worktree의 git dir에서 pre-push hook 파일을 임시로 이름 변경
           const gitDir = await this.resolveGitDir(repoPath)
           const hookPath = join(gitDir, 'hooks', 'pre-push')
           const backupPath = hookPath + '.bak'
           let hookExists = false
           try:
             await rename(hookPath, backupPath)
             hookExists = true
           catch:
             무시 -- hook이 없는 경우

           try:
             await this.exec(repoPath, ['push', 'origin', '--', branch])
           finally:
             if hookExists:
               try: await rename(backupPath, hookPath)
               catch: 무시

       resolveGitDir 헬퍼 메서드 추가:
         private async resolveGitDir(repoPath: string): Promise<string>
           const gitPath = join(repoPath, '.git')
           try:
             const content = await readFile(gitPath, 'utf-8')
             if content.startsWith('gitdir:'):
               return content.replace('gitdir:', '').trim()
           catch:
             무시
           return gitPath

       import 추가: rename from node:fs/promises

1-3. PushWorkspaceBranchesUseCase 생성 (워크스페이스용)

     파일: flow-backend/src/workspace/application/commands/push-workspace-branches-use-case.ts

     PushBranchesUseCase와 유사한 구조이되 WorkspaceRepository 사용.

     @Injectable 데코레이터
     생성자 주입: WorkspaceRepository, GitService, GitReader

     async execute(workspaceId: WorkspaceId): Promise<PushBranchesResult>
       workspace = await workspaceRepository.findById(workspaceId)
       없으면 에러
       if workspace.status !== WorkspaceStatus.COMPLETED then 에러

       const gitInfos = await gitReader.findByIds(workspace.gitRefs.map(r => r.gitId))

       const results: PushResult[] = []
       for each gitRef of workspace.gitRefs:
         const gitInfo = gitInfos.find(g => g.id === gitRef.gitId)
         -- workspace의 worktree 경로 계산
         -- workspace.path 내의 symlink를 통해 경로를 찾거나 pathFactory 사용
         const workTreePath = -- 경로 결정

         try:
           await gitService.push(workTreePath, gitRef.branchName)
           results.push({ gitId: gitRef.gitId, branch: gitRef.branchName, success: true, error: null })
         catch err:
           results.push({
             gitId: gitRef.gitId, branch: gitRef.branchName, success: false,
             error: err instanceof Error ? err.message : String(err),
           })

       return { results }

1-4. 런타임 컨트롤러에 push 엔드포인트 추가

     @Post(':id/push')
     @HttpCode(200)
     async pushBranches(@Param('id', BrandedIdPipe(WorkflowRunId)) id: WorkflowRunId)
       return this.pushBranchesUseCase.execute(id)

     생성자에 PushBranchesUseCase 주입.
     모듈의 providers에 PushBranchesUseCase 추가.

1-5. 워크스페이스 컨트롤러에 push 엔드포인트 추가

     @Post(':id/push')
     @HttpCode(200)
     async pushBranches(@Param('id') id: string)
       return this.pushWorkspaceBranchesUseCase.execute(WorkspaceId.create(id))

     생성자에 PushWorkspaceBranchesUseCase 주입.
     모듈의 providers에 PushWorkspaceBranchesUseCase 추가.

1-6. 백엔드 검증 실행


----- Phase 2 백엔드 -- MergeBranchesUseCase -- B1, B2 -----

핵심 파일:
  - flow-backend/src/workspace/application/commands/merge-branches-use-case.ts -- 신규
  - flow-backend/src/workspace/presentation/workspace.controller.ts -- 수정
  - flow-backend/src/workspace/presentation/dto/merge-branches.dto.ts -- 신규
  - flow-backend/src/workspace/presentation/workspace.module.ts -- 수정
참조할 코드 -- 읽기만, 수정하지 않음:
  - flow-backend/src/workspace/application/commands/send-chat-message-use-case.ts -- 채팅 위임 패턴
  - flow-backend/src/workflow-runtime/domain/ports/work-tree-repository.ts -- WorkTree 조회

2-1. MergeBranchesUseCase 생성

     @Injectable 데코레이터
     생성자 주입:
       - WorkspaceRepository
       - WorkTreeRepository (workflow-runtime 도메인에서 가져옴)
       - WorkflowRunRepository (workflow-runtime 도메인에서 가져옴)
       - AgentService
       - GitReader

     MergeBranchesCommand 인터페이스:
       workspaceId: WorkspaceId
       workflowRunIds: string[] -- 통합할 워크플로우 런 ID 목록

     async execute(command: MergeBranchesCommand): Promise<{ response: string }>

     execute 로직:
       1. workspace = await workspaceRepository.findById(command.workspaceId)
          없으면 에러
          if not workspace.isActive() then 에러

       2. 각 워크플로우 런에서 브랜치 정보 수집:
          -- gitId별로 머지할 브랜치 목록 집계
          const mergePlan = new Map<string, { gitId: string; branches: string[] }>()

          for each runId of command.workflowRunIds:
            const workTrees = await workTreeRepository.findByWorkflowRunId(
              WorkflowRunId.create(runId)
            )
            for each wt of workTrees:
              const existing = mergePlan.get(wt.gitId) ?? { gitId: wt.gitId, branches: [] }
              -- 현재 브랜치명 확인 (worktree에서)
              const branchName = wt.branch -- 또는 실제 getCurrentBranch 호출
              if not existing.branches.includes(branchName):
                existing.branches.push(branchName)
              mergePlan.set(wt.gitId, existing)

       3. 머지 계획을 채팅 메시지로 구성:
          const gitInfos = await gitReader.findByIds([...mergePlan.keys()])

          let message = '다음 브랜치들을 현재 워크스페이스의 각 프로젝트에 머지해주세요.\n\n'
          for each [gitId, plan] of mergePlan:
            const gitInfo = gitInfos.find(g => g.id === gitId)
            const projectName = gitInfo?.url.split('/').pop()?.replace('.git', '') ?? gitId
            message += '프로젝트: ' + projectName + '\n'
            message += '머지할 브랜치: ' + plan.branches.join(', ') + '\n'
            -- workspace에서 해당 gitId의 브랜치명 확인
            const wsGitRef = workspace.gitRefs.find(r => r.gitId === gitId)
            if wsGitRef:
              message += '현재 브랜치: ' + wsGitRef.branchName + '\n'
            message += '\n'

          message += '각 프로젝트 디렉토리에서 git merge 명령으로 브랜치를 통합해주세요. '
          message += '충돌이 발생하면 적절히 해결해주세요.'

       4. 에이전트에게 메시지 전송:
          const result = await agentService.sendQueryForWorkspace(
            workspace.id, message
          )

          return { response: result.response }

2-2. DTO 생성

     파일: flow-backend/src/workspace/presentation/dto/merge-branches.dto.ts

     export class MergeBranchesDto:
       @IsArray()
       @IsString({ each: true })
       workflowRunIds: string[]

2-3. 워크스페이스 컨트롤러에 merge 엔드포인트 추가

     @Post(':id/merge')
     @HttpCode(200)
     async mergeBranches(
       @Param('id') id: string,
       @Body() dto: MergeBranchesDto,
     )
       return this.mergeBranchesUseCase.execute({
         workspaceId: WorkspaceId.create(id),
         workflowRunIds: dto.workflowRunIds,
       })

     생성자에 MergeBranchesUseCase 주입.
     모듈에 등록:
       providers에 MergeBranchesUseCase 추가.
       WorkflowRunRepository, WorkTreeRepository를 inject 하려면
       WorkflowRuntimeModule에서 export하거나 SharedModule에서 제공해야 한다.
       기존 모듈 간 의존성을 확인하고 적절히 import를 추가한다.

2-4. 백엔드 검증 실행


----- Phase 3 프론트엔드 -- 푸시 UI -- C1, C2 -----

핵심 파일:
  - flow-front/src/api/types.ts -- 수정
  - flow-front/src/api/workflow-runs.ts -- 수정
  - flow-front/src/api/workspaces.ts -- 수정
  - flow-front/src/hooks/useWorkflowRuns.ts -- 수정
  - flow-front/src/hooks/useWorkspaces.ts -- 수정
  - flow-front/src/pages/WorkflowRunFlowPage.tsx -- 수정
  - flow-front/src/pages/WorkspaceDetailPage.tsx -- 수정
  - flow-front/src/components/PushResultDialog.tsx -- 신규
참조할 코드 -- 읽기만, 수정하지 않음:
  - flow-front/src/components/ConfirmDialog.tsx -- 다이얼로그 패턴

3-1. 타입 추가 -- flow-front/src/api/types.ts

     export interface PushResult {
       gitId: string;
       branch: string;
       success: boolean;
       error: string | null;
     }

     export interface PushBranchesResult {
       results: PushResult[];
     }

3-2. API 모듈 수정

     workflow-runs.ts에 추가:
       pushBranches: (id: string) =>
         apiClient.post<unknown, PushBranchesResult>('/workflow-runs/' + id + '/push')

     workspaces.ts에 추가:
       pushBranches: (id: string) =>
         apiClient.post<unknown, PushBranchesResult>('/workspaces/' + id + '/push')

3-3. 훅 수정

     useWorkflowRunDetail에 pushMutation 추가:
       mutationFn: () => workflowRunsApi.pushBranches(id)
       onSuccess: invalidate detail

     useWorkspaceDetail에 pushMutation 추가:
       mutationFn: () => workspacesApi.pushBranches(id)
       onSuccess: invalidate detail

3-4. PushResultDialog 컴포넌트 생성

     파일: flow-front/src/components/PushResultDialog.tsx

     Props:
       open: boolean
       onClose: () => void
       results: PushResult[] | null

     구조:
       Dialog 컴포넌트 (기존 ui/dialog 사용):
         제목: "원격 푸시 결과"
         결과 테이블:
           컬럼: 프로젝트, 브랜치, 결과
           각 행:
             프로젝트: gitId (또는 URL에서 추출한 이름)
             브랜치: branch
             결과: success이면 체크마크 + 성공, 아니면 X + 에러 메시지
         닫기 버튼

3-5. WorkflowRunFlowPage에 푸시 버튼 추가

     COMPLETED 상태일 때 상단 액션 영역에 버튼 추가:
       Button variant=default size=sm:
         Upload 아이콘 (lucide-react)
         "원격 푸시"
       onClick: 확인 다이얼로그 표시 후 pushMutation.mutate()
       pushMutation 성공 시: PushResultDialog 열기

     확인 다이얼로그:
       "로컬 브랜치를 원격 저장소로 푸시합니다. 계속하시겠습니까?"

     PushResultDialog:
       open: pushResultOpen 상태
       results: pushMutation.data?.results

     import 추가: PushResultDialog, Upload from lucide-react

3-6. WorkspaceDetailPage에 푸시 버튼 추가

     WorkflowRunFlowPage와 동일한 패턴.
     COMPLETED 상태일 때만 표시.

3-7. 프론트엔드 검증 실행


----- Phase 4 프론트엔드 -- 리니지 통합 UI -- D1 -----

핵심 파일:
  - flow-front/src/api/types.ts -- 수정
  - flow-front/src/api/workspaces.ts -- 수정
  - flow-front/src/hooks/useWorkspaces.ts -- 수정
  - flow-front/src/pages/WorkLineagePage.tsx -- 수정
  - flow-front/src/components/MergeDialog.tsx -- 신규
참조할 코드 -- 읽기만, 수정하지 않음:
  - flow-front/src/components/ConfirmDialog.tsx -- 다이얼로그 패턴
  - flow-front/src/hooks/useWorkspaces.ts -- workspace 목록 조회

4-1. 타입 추가

     export interface MergeBranchesRequest {
       workflowRunIds: string[];
     }

     export interface MergeBranchesResponse {
       response: string;
     }

4-2. API 모듈에 merge 추가

     workspaces.ts에 추가:
       mergeBranches: (workspaceId: string, data: MergeBranchesRequest) =>
         apiClient.post<unknown, MergeBranchesResponse>(
           '/workspaces/' + workspaceId + '/merge', data
         )

4-3. MergeDialog 컴포넌트 생성

     파일: flow-front/src/components/MergeDialog.tsx

     Props:
       open: boolean
       onClose: () => void
       selectedRunIds: string[] -- 선택된 워크플로우 런 ID 목록
       onMerge: (workspaceId: string) => void

     구조:
       Dialog:
         제목: "브랜치 통합"
         설명: "선택한 워크플로우의 브랜치를 워크스페이스로 머지합니다."

         워크스페이스 선택:
           ACTIVE 상태의 워크스페이스 목록을 useWorkspaceList로 조회
           Select 또는 Combobox로 워크스페이스 선택
           selectedWorkspaceId 상태

         선택된 런 요약:
           "X개의 워크플로우 런이 선택되었습니다."

         통합 버튼:
           disabled: selectedWorkspaceId가 없으면
           onClick: onMerge(selectedWorkspaceId)

         취소 버튼

4-4. WorkLineagePage 수정

     체크박스 선택 기능 추가:
       useState<Set<string>> 으로 selectedRunIds 관리

       각 워크플로우 런 행에 체크박스 추가:
         checked: selectedRunIds.has(runInfo.workflowRunId)
         onChange: 토글

       상단 액션 영역에 "통합" 버튼 추가:
         disabled: selectedRunIds.size === 0
         onClick: MergeDialog 열기

     MergeDialog:
       open: mergeDialogOpen 상태
       selectedRunIds: [...selectedRunIds]
       onMerge: async (workspaceId) => {
         await workspacesApi.mergeBranches(workspaceId, {
           workflowRunIds: [...selectedRunIds],
         })
         -- 성공 시:
         setMergeDialogOpen(false)
         setSelectedRunIds(new Set())
         -- 해당 워크스페이스 상세 페이지로 이동 (선택적)
         navigate('/workspaces/' + workspaceId)
       }

     체크박스 UI:
       각 확장된 테이블의 런 행에:
         td 추가 (체크박스 컬럼):
           input type=checkbox
           COMPLETED 상태인 런만 체크 가능
           RUNNING 등은 비활성화

4-5. 프론트엔드 검증 실행


----- Phase 5 통합 검증 -----

5-1. 백엔드 서버 빌드 후 실행:
     cd flow-backend && npm run build && npm run start

5-2. 프론트엔드 dev 서버 실행:
     cd flow-front && npm run dev

5-3. Playwright MCP로 다음 시나리오를 검증:

     시나리오 A -- 워크플로우 런 원격 푸시:
       완료된 워크플로우 런 상세 페이지 (/workflow-runs/:id) 접속
       "원격 푸시" 버튼 표시 확인
       버튼 클릭 → 확인 다이얼로그 표시
       확인 클릭 → 푸시 실행
       PushResultDialog에 프로젝트별 결과 표시 확인

     시나리오 B -- 워크스페이스 원격 푸시:
       완료된 워크스페이스 상세 페이지 접속
       "원격 푸시" 버튼 표시 확인 (COMPLETED 상태에서만)
       ACTIVE 상태에서는 표시되지 않는지 확인

     시나리오 C -- 리니지에서 브랜치 통합:
       /work-lineage 페이지 접속
       완료된 런의 체크박스 선택 (1개 이상)
       "통합" 버튼 활성화 확인
       클릭 → MergeDialog 열림
       ACTIVE 워크스페이스 목록에서 선택
       "통합" 버튼 클릭 → 머지 요청 실행
       성공 시 워크스페이스 상세 페이지로 이동 확인
       채팅 패널에 머지 관련 에이전트 메시지 표시 확인

     시나리오 D -- 실행 중인 런은 푸시 불가:
       RUNNING 상태의 런 상세 페이지에서 "원격 푸시" 버튼이 없는지 확인

     시나리오 E -- 실행 중인 런은 체크 불가:
       리니지 페이지에서 RUNNING 상태의 런은 체크박스가 비활성화인지 확인

5-4. 문제 발견 시 즉시 수정하고 재검증

5-5. 최종 검증:
     cd flow-backend && npm run typecheck && npm run test && npm run lint
     cd flow-front && npx tsc -b && npm run lint && npm run build

BRANCH MERGE + SELECTIVE PUSH COMPLETE 를 출력한다.
