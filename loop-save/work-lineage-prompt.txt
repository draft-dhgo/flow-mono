이슈키별 워크플로우 브랜치/커밋 현황을 테이블로 조회하고, 마크다운 형식으로 추출하는 작업 리니지 기능을 추가한다.
flow-front/CLAUDE.md와 flow-backend/CLAUDE.md의 모든 규칙을 준수한다.

선행 조건:
  git-safety-prompt.txt가 먼저 실행되어 GitClient/GitService에 getCommitCount, getLog, getCurrentCommit, getCurrentBranch 메서드가 추가되어 있어야 한다.

작업 리니지란:
  워크플로우 런이 완료되면 각 git 레포지토리의 로컬 브랜치에 커밋이 쌓인다.
  작업 리니지는 이슈키별로 어떤 프로젝트(git 레포)에 어떤 브랜치가 있고, 몇 개의 커밋이 있는지를 한눈에 보여주는 테이블이다.
  이 정보를 마크다운 테이블로 추출하여 이슈 트래커나 문서에 붙여넣을 수 있다.

수정할 항목 목록:
  A1. GetWorkLineageQuery -- 리니지 데이터 집계
  A2. ExportWorkLineageQuery -- 마크다운 테이블 변환
  B1. 컨트롤러에 리니지 엔드포인트 추가
  B2. 모듈에 쿼리 등록
  C1. 프론트엔드 API 타입 + 모듈
  C2. React Query 훅
  C3. WorkLineagePage 컴포넌트
  C4. Sidebar + 라우트 추가

아래 4개 Phase를 순서대로 진행한다.
각 Phase 완료 후 반드시 아래 검증을 실행한다. 검증 실패 시 수정 후 다시 검증한다.
  백엔드 검증: cd flow-backend && npm run typecheck && npm run test && npm run lint
  프론트엔드 검증: cd flow-front && npx tsc -b && npm run lint && npm run build
각 Phase 완료 후 Playwright MCP를 통해 localhost:5173에 접속하여 실제 화면을 확인하고 문제가 있으면 즉시 수정한다.


----- Phase 1 백엔드 -- GetWorkLineageQuery + ExportWorkLineageQuery -- A1, A2 -----

핵심 파일:
  - flow-backend/src/workflow-runtime/application/queries/get-work-lineage-query.ts -- 신규
  - flow-backend/src/workflow-runtime/application/queries/export-work-lineage-query.ts -- 신규
참조할 코드 -- 읽기만, 수정하지 않음:
  - flow-backend/src/workflow-runtime/application/queries/list-workflow-runs-query.ts -- 쿼리 패턴
  - flow-backend/src/workflow-runtime/domain/ports/work-tree-repository.ts -- WorkTree 조회
  - flow-backend/src/common/ports/git-service.ts -- getCommitCount, getCurrentCommit, getCurrentBranch
  - flow-backend/src/common/ports/git-reader.ts -- findByIds
  - flow-backend/src/common/ports/workflow-config-reader.ts -- 워크플로우 이름 조회

1-1. 응답 인터페이스 정의

     export interface WorkLineageRepoInfo:
       gitId -- string
       gitUrl -- string
       branch -- string
       commitHash -- string
       commitCount -- number

     export interface WorkLineageRunInfo:
       workflowRunId -- string
       workflowName -- string
       runStatus -- string
       repos -- WorkLineageRepoInfo 배열

     export interface WorkLineageEntry:
       issueKey -- string
       runs -- WorkLineageRunInfo 배열

1-2. GetWorkLineageQuery 생성 -- flow-backend/src/workflow-runtime/application/queries/get-work-lineage-query.ts

     @Injectable 데코레이터.
     생성자 주입:
       - WorkflowRunRepository
       - WorkTreeRepository
       - GitService
       - GitReader
       - WorkflowConfigReader

     async execute -- returns Promise<WorkLineageEntry 배열>

     execute 로직:
       1. const runs = await this.workflowRunRepository.findAll()
          -- 모든 워크플로우 런 조회

       2. issueKey 기준으로 그룹핑:
          const groupedByIssueKey = new Map<string, WorkflowRun[]>()
          for each run of runs:
            const existing = groupedByIssueKey.get(run.issueKey) 또는 빈 배열
            existing.push(run)
            groupedByIssueKey.set(run.issueKey, existing)

       3. 각 그룹에 대해 리니지 엔트리 생성:
          const entries: WorkLineageEntry[] = []
          for each [issueKey, runsForKey] of groupedByIssueKey:
            const runInfos: WorkLineageRunInfo[] = []
            for each run of runsForKey:
              -- 워크플로우 이름 조회
              const workflow = await this.workflowConfigReader.findById(run.workflowId)
              const workflowName = workflow?.name ?? 'Unknown'

              -- WorkTree 목록 조회
              const workTrees = await this.workTreeRepository.findByWorkflowRunId(run.id)

              -- 각 worktree의 git 정보 조회
              const gitIds = workTrees.map(wt => wt.gitId)
              const gitInfos = gitIds.length > 0 ? await this.gitReader.findByIds(gitIds) : []

              const repos: WorkLineageRepoInfo[] = []
              for each wt of workTrees:
                const gitInfo = gitInfos.find(g => g.id === wt.gitId)
                try:
                  const branch = await this.gitService.getCurrentBranch(wt.path)
                     -- getCurrentBranch가 GitService에 없으면 GitClient에서 직접 호출하거나
                     -- GitService에 추가 필요. 기존 코드를 확인하고, 없으면 추가한다.
                     -- 대안: wt.branch 필드를 사용하되, 실제 현재 브랜치는 다를 수 있음
                  const commitHash = await this.gitService.getCurrentCommit(wt.path)
                  -- gitRefPool에서 해당 gitId의 baseBranch 찾기
                  const gitRef = run.gitRefPool.find(ref => ref.gitId === wt.gitId)
                  const baseBranch = gitRef?.baseBranch ?? 'main'
                  let commitCount = 0
                  try:
                    commitCount = await this.gitService.getCommitCount(wt.path, baseBranch)
                  catch:
                    commitCount = 0
                  repos.push({
                    gitId: wt.gitId,
                    gitUrl: gitInfo?.url ?? '',
                    branch,
                    commitHash,
                    commitCount,
                  })
                catch:
                  -- worktree가 삭제되었거나 접근 불가 시 스킵
                  repos.push({
                    gitId: wt.gitId,
                    gitUrl: gitInfo?.url ?? '',
                    branch: wt.branch,
                    commitHash: 'N/A',
                    commitCount: 0,
                  })

              runInfos.push({
                workflowRunId: run.id,
                workflowName,
                runStatus: run.status,
                repos,
              })

            entries.push({ issueKey, runs: runInfos })

       4. entries를 issueKey 알파벳순 정렬하여 반환

     주의: GitService에 getCurrentBranch 메서드가 없을 수 있다.
       없으면 GitService 포트와 GitServiceImpl에 추가:
         abstract getCurrentBranch(repoPath: string): Promise<string>
         구현: return this.gitClient.getCurrentBranch(repoPath)

     import:
       Injectable from @nestjs/common
       WorkflowRunRepository from 도메인 인덱스
       WorkTreeRepository from 도메인 포트
       GitService, GitReader, WorkflowConfigReader from @common/ports/index.js
       WorkflowRunId -- 타입

1-3. ExportWorkLineageQuery 생성 -- flow-backend/src/workflow-runtime/application/queries/export-work-lineage-query.ts

     @Injectable 데코레이터.
     생성자 주입:
       - GetWorkLineageQuery

     async execute -- returns Promise<string>

     execute 로직:
       1. const entries = await this.getWorkLineageQuery.execute()
       2. 마크다운 테이블로 변환:

          빈 entries이면: return '리니지 데이터가 없습니다.'

          const lines: string[] = []
          lines.push('# 작업 리니지')
          lines.push('')

          for each entry of entries:
            lines.push('## ' + entry.issueKey)
            lines.push('')
            lines.push('| 워크플로우 | 상태 | 프로젝트 | 브랜치 | 커밋 해시 | 커밋 수 |')
            lines.push('|---|---|---|---|---|---|')

            for each runInfo of entry.runs:
              if runInfo.repos.length === 0:
                lines.push('| ' + runInfo.workflowName + ' | ' + runInfo.runStatus + ' | - | - | - | 0 |')
              else:
                for each (repo, idx) of runInfo.repos:
                  -- 첫 번째 repo는 워크플로우명과 상태 표시, 나머지는 빈칸
                  const wfName = idx === 0 ? runInfo.workflowName : ''
                  const status = idx === 0 ? runInfo.runStatus : ''
                  -- gitUrl에서 프로젝트명 추출: URL의 마지막 segment에서 .git 제거
                  const projectName = repo.gitUrl.split('/').pop()?.replace('.git', '') ?? repo.gitId
                  const shortHash = repo.commitHash === 'N/A' ? 'N/A' : repo.commitHash.substring(0, 7)
                  lines.push('| ' + wfName + ' | ' + status + ' | ' + projectName + ' | ' + repo.branch + ' | ' + shortHash + ' | ' + String(repo.commitCount) + ' |')

            lines.push('')

          return lines.join('\n')

     import:
       Injectable from @nestjs/common
       GetWorkLineageQuery from ./get-work-lineage-query.js

1-4. 백엔드 검증 실행


----- Phase 2 백엔드 -- 컨트롤러 엔드포인트 -- B1, B2 -----

핵심 파일:
  - flow-backend/src/workflow-runtime/presentation/workflow-runtime.controller.ts -- 수정
  - flow-backend/src/workflow-runtime/presentation/workflow-runtime.module.ts -- 수정

2-1. 컨트롤러에 엔드포인트 추가

     주의: 리니지 엔드포인트는 별도 컨트롤러를 만들거나 기존 런타임 컨트롤러에 추가한다.
     기존 런타임 컨트롤러에 추가하는 경우:

     생성자에 주입 추가:
       private readonly getWorkLineageQuery: GetWorkLineageQuery
       private readonly exportWorkLineageQuery: ExportWorkLineageQuery

     GET 엔드포인트 추가:
       @Get('work-lineage')
       async getWorkLineage():
         return this.getWorkLineageQuery.execute()

     GET 엔드포인트 추가:
       @Get('work-lineage/export')
       @Header('Content-Type', 'text/markdown; charset=utf-8')
       async exportWorkLineage(@Res() res: Response):
         const markdown = await this.exportWorkLineageQuery.execute()
         res.setHeader('Content-Type', 'text/markdown; charset=utf-8')
         res.send(markdown)

     주의: @Res() 사용 시 NestJS의 자동 직렬화가 비활성화된다.
     또는 @Header 데코레이터만 사용하고 문자열을 직접 반환하는 방법:
       @Get('work-lineage/export')
       @Header('Content-Type', 'text/markdown; charset=utf-8')
       async exportWorkLineage(): Promise<string>:
         return this.exportWorkLineageQuery.execute()

     import 추가:
       Header from @nestjs/common -- 기존 import에 합침
       GetWorkLineageQuery, ExportWorkLineageQuery

     주의: 경로 충돌 방지.
     런타임 컨트롤러의 기존 경로가 @Controller('workflow-runs')이면
     리니지 엔드포인트는 /workflow-runs/work-lineage 와 /workflow-runs/work-lineage/export 가 된다.
     또는 별도 @Controller('work-lineage') 컨트롤러를 만들면 /work-lineage 와 /work-lineage/export 가 된다.
     -- 별도 컨트롤러 추천: 도메인 분리가 명확

     별도 컨트롤러 생성 시:
       flow-backend/src/workflow-runtime/presentation/work-lineage.controller.ts 신규 생성
       @Controller('work-lineage') 데코레이터
       @UseGuards(JwtAuthGuard) -- 기존 런타임 컨트롤러 패턴 따름
       생성자에 GetWorkLineageQuery, ExportWorkLineageQuery 주입
       GET / → getWorkLineage()
       GET /export → exportWorkLineage()

2-2. 모듈에 쿼리 + 컨트롤러 등록

     workflow-runtime.module.ts의 providers에 추가:
       GetWorkLineageQuery
       ExportWorkLineageQuery

     controllers에 추가 (별도 컨트롤러 생성 시):
       WorkLineageController

     import 추가

2-3. 백엔드 검증 실행


----- Phase 3 프론트엔드 -- API + 리니지 페이지 -- C1, C2, C3, C4 -----

핵심 파일:
  - flow-front/src/api/types.ts -- 수정
  - flow-front/src/api/work-lineage.ts -- 신규
  - flow-front/src/lib/query-keys.ts -- 수정
  - flow-front/src/hooks/useWorkLineage.ts -- 신규
  - flow-front/src/pages/WorkLineagePage.tsx -- 신규
  - flow-front/src/components/layout/Sidebar.tsx -- 수정
  - flow-front/src/App.tsx -- 수정
참조할 코드 -- 읽기만, 수정하지 않음:
  - flow-front/src/api/workflow-runs.ts -- API 모듈 패턴
  - flow-front/src/hooks/useWorkflowRuns.ts -- 훅 패턴
  - flow-front/src/pages/WorkflowRunListPage.tsx -- 테이블 페이지 패턴
  - flow-front/src/components/DataTable.tsx -- 테이블 컴포넌트

3-1. 타입 추가 -- flow-front/src/api/types.ts

     파일 하단에 추가:

     // --- Work Lineage ---

     export interface WorkLineageRepoInfo {
       gitId: string;
       gitUrl: string;
       branch: string;
       commitHash: string;
       commitCount: number;
     }

     export interface WorkLineageRunInfo {
       workflowRunId: string;
       workflowName: string;
       runStatus: string;
       repos: WorkLineageRepoInfo[];
     }

     export interface WorkLineageEntry {
       issueKey: string;
       runs: WorkLineageRunInfo[];
     }

3-2. API 모듈 생성 -- flow-front/src/api/work-lineage.ts

     import apiClient from './client';
     import type { WorkLineageEntry } from './types';

     export const workLineageApi = {
       getLineage: () =>
         apiClient.get<unknown, WorkLineageEntry[]>('/work-lineage'),

       exportLineage: async (): Promise<string> => {
         const response = await apiClient.get<unknown, string>('/work-lineage/export', {
           responseType: 'text',
           transformResponse: [(data: string) => data],
         });
         return response as unknown as string;
       },
     };

     주의: export의 경우 text/markdown 응답이므로 responseType과 transformResponse 설정.
     axios 인터셉터가 response.data를 자동 추출하므로 이를 고려.

3-3. 쿼리 키 추가 -- flow-front/src/lib/query-keys.ts

     queryKeys 객체에 추가:
       workLineage: {
         all: ['work-lineage'] as const,
         export: ['work-lineage', 'export'] as const,
       },

3-4. React Query 훅 생성 -- flow-front/src/hooks/useWorkLineage.ts

     import { useQuery } from '@tanstack/react-query';
     import { queryKeys } from '@/lib/query-keys';
     import { workLineageApi } from '@/api/work-lineage';

     export function useWorkLineage() {
       const lineageQuery = useQuery({
         queryKey: queryKeys.workLineage.all,
         queryFn: workLineageApi.getLineage,
         refetchInterval: 10000, -- 10초마다 갱신
       });

       return { lineageQuery };
     }

3-5. WorkLineagePage 생성 -- flow-front/src/pages/WorkLineagePage.tsx

     import:
       useWorkLineage from @/hooks/useWorkLineage
       workLineageApi from @/api/work-lineage
       PageHeader from @/components/layout/PageHeader
       StatusBadge from @/components/StatusBadge -- 또는 직접 배지 생성
       Button from @/components/ui/button
       LoadingSpinner from @/components/LoadingSpinner
       ChevronDown, ChevronRight, Copy, Download from lucide-react
       useState from react
       RUN_STATUS_COLOR, RUN_STATUS_LABEL from @/lib/constants

     컴포넌트 구조:

       const { lineageQuery } = useWorkLineage()
       const [expandedKeys, setExpandedKeys] = useState<Set<string>>(new Set())

       토글 함수:
         const toggleKey = (key: string) => {
           setExpandedKeys(prev => {
             const next = new Set(prev)
             if (next.has(key)) next.delete(key)
             else next.add(key)
             return next
           })
         }

       마크다운 복사 함수:
         const handleCopyMarkdown = async () => {
           const markdown = await workLineageApi.exportLineage()
           await navigator.clipboard.writeText(markdown)
           -- 복사 완료 알림 (간단한 상태 변경 또는 toast)
         }

       마크다운 다운로드 함수:
         const handleDownloadMarkdown = async () => {
           const markdown = await workLineageApi.exportLineage()
           const blob = new Blob([markdown], { type: 'text/markdown' })
           const url = URL.createObjectURL(blob)
           const a = document.createElement('a')
           a.href = url
           a.download = 'work-lineage.md'
           a.click()
           URL.revokeObjectURL(url)
         }

       렌더링:
         PageHeader title="작업 리니지"

         상단 액션 버튼:
           Button variant=outline size=sm onClick=handleCopyMarkdown:
             Copy 아이콘 + "마크다운 복사"
           Button variant=outline size=sm onClick=handleDownloadMarkdown:
             Download 아이콘 + "마크다운 다운로드"

         로딩 중이면 LoadingSpinner 표시.
         데이터 없으면 빈 상태 메시지.

         이슈키별 아코디언 테이블:
           for each entry of lineageQuery.data:
             div -- border rounded-lg mb-3:
               헤더 div -- cursor-pointer, flex items-center justify-between, p-3, bg-muted/30:
                 onClick: toggleKey(entry.issueKey)
                 좌측:
                   ChevronDown 또는 ChevronRight 아이콘 (expanded 여부)
                   span font-semibold: entry.issueKey
                   span text-muted-foreground text-sm: entry.runs.length + '개 실행'
                 우측:
                   실행 수 및 상태 요약 표시

               expanded이면 콘텐츠 div -- p-3:
                 table -- w-full text-sm:
                   thead:
                     tr:
                       th: 워크플로우
                       th: 상태
                       th: 프로젝트
                       th: 브랜치
                       th: 커밋 해시
                       th: 커밋 수
                   tbody:
                     for each runInfo of entry.runs:
                       if runInfo.repos.length === 0:
                         tr:
                           td: runInfo.workflowName
                           td: 상태 배지
                           td colspan=4: -
                       else:
                         for each (repo, idx) of runInfo.repos:
                           tr:
                             td: idx === 0 ? runInfo.workflowName : ''
                             td: idx === 0 ? 상태 배지 : ''
                             td: URL에서 추출한 프로젝트명
                             td: repo.branch -- code 태그
                             td: repo.commitHash.substring(0, 7) -- code 태그, monospace
                             td: repo.commitCount

         프로젝트명 추출 유틸:
           function extractProjectName(gitUrl: string): string {
             return gitUrl.split('/').pop()?.replace('.git', '') ?? gitUrl;
           }

3-6. Sidebar에 네비게이션 추가 -- flow-front/src/components/layout/Sidebar.tsx

     lucide-react에서 GitPullRequest 또는 Network 아이콘 import.
     navItems에 Runs 다음 위치에 추가:
       { to: '/work-lineage', label: 'Lineage', icon: Network }

3-7. App.tsx에 라우트 추가 -- flow-front/src/App.tsx

     import WorkLineagePage from @/pages/WorkLineagePage
     Route 추가 -- 기존 라우트들 사이에:
       path: '/work-lineage'
       element: <WorkLineagePage />

3-8. 프론트엔드 검증 실행


----- Phase 4 통합 검증 -----

4-1. 백엔드 서버 빌드 후 실행:
     cd flow-backend && npm run build && npm run start

4-2. 프론트엔드 dev 서버 실행:
     cd flow-front && npm run dev

4-3. Playwright MCP로 다음 시나리오를 검증:

     시나리오 A -- 리니지 페이지 접근:
       사이드바에서 Lineage 메뉴 클릭
       /work-lineage 경로로 이동하는지 확인
       PageHeader에 "작업 리니지" 텍스트 표시

     시나리오 B -- 리니지 데이터 표시:
       완료된 워크플로우 런이 있다면:
         이슈키별 아코디언 항목이 표시되는지 확인
         이슈키 클릭 시 확장되어 테이블이 표시되는지 확인
         테이블에 워크플로우명, 상태, 프로젝트, 브랜치, 커밋 해시, 커밋 수가 표시되는지 확인
       없다면:
         빈 상태 메시지가 표시되는지 확인

     시나리오 C -- 마크다운 복사:
       마크다운 복사 버튼 클릭 -- 에러 없이 동작하는지 확인

     시나리오 D -- 마크다운 다운로드:
       마크다운 다운로드 버튼 클릭 -- work-lineage.md 파일 다운로드

4-4. 문제 발견 시 즉시 수정하고 재검증

4-5. 최종 검증:
     cd flow-backend && npm run typecheck && npm run test && npm run lint
     cd flow-front && npx tsc -b && npm run lint && npm run build

WORK LINEAGE TABLE + MARKDOWN EXPORT COMPLETE 를 출력한다.
